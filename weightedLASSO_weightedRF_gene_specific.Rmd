---
title: "Gene-specific tuning of integrative GRN inference"
output: 
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F, fig.width = 10)

source('inference_functions/weightedRF.R')
source('inference_functions/weightedLASSO.R')
source('inference_functions/evaluateNetwork.R')
source('inference_functions/data_integration_optimization.R')

library(ggplot2)
library(tidyverse)
library(ggpubr)
library(patchwork)
library(ggVennDiagram)
library(ComplexHeatmap)
library(clusterProfiler)
library(circlize)
```

This document demonstrates the use of the weightedRF and weightedLASSO functions for integrative GRN inference.

It shows how to select one optimal alpha value per gene, in order to apply data integration only to the target genes for which expression prediction error is reduced by using PWM prior information, significantly more than in a baseline model.

# Data import

Import of the expression data and binding motifs data for the nitrate-responsive genes and regulators :

```{r}
load('rdata/inference_input_N_response_varala.rdata')
genes <- input_data$grouped_genes; length(genes)
tfs <- input_data$grouped_regressors; length(tfs)
counts <- input_data$counts; dim(counts)
load("rdata/pwm_occurrences_N_response_varala.rdata")
dim(pwm_occurrence)

ALPHAS <- seq(0,1, by = 0.1)
```


# Getting inferred GRNs over a whole range of global alpha values

For $alpha$ from 0 to 1 with a step of 0.1, we infer 100 or 50 integrative models on 

+ true data

+ a shuffled baseline, corresponding to a simulated null hypothesis.

The following code chunks are very long to run (even in multitasking), and save their results in `reslults/rdata`, a folder which should be created beforehand.
Results are a matrix of TF-target importances, edges, MSE values, and validation against DAP-Seq. 

## For weightedRF

```{r, eval=FALSE}
nCores = 45
mats <- list()
nrep <- 100
for(alpha in ALPHAS){ # exploring PWM integration strength
  for(rep in 1:nrep){ # exploring inherent variability
    
    mat_rf <- weightedRF_inference(counts, genes, tfs, nTrees = 2000,
                            alpha = alpha,
                            pwm_occurrence = pwm_occurrence,
                            nCores = nCores,
                            importance = "%IncMSE")
    
    mat_rf_perm <- weightedRF_inference(counts, genes, tfs, nTrees = 2000,
                            alpha = alpha, tf_expression_permutation = TRUE,
                            pwm_occurrence = pwm_occurrence,
                            nCores = nCores,
                            importance = "%IncMSE")
    
    mats[[paste0("bRF_", as.character(alpha),  '_trueData_', rep)]] <- mat_rf
    mats[[paste0("bRF_", as.character(alpha),  '_shuffled_', rep)]] <- mat_rf_perm
    
  }
}
save(mats, file = "results/rdata/weightedRF_importances_100rep.rdata")

# thresholds the regulatory weights at a certain density to build GRNs
edges <- list()
lmses <- data.frame(row.names = genes)
densities <- c(0.005, 0.01,0.05)
for(name in names(mats)){ 
      for(density in densities){# exploring importance threshold stringency
        edges[[paste0(name, '_', density)]] <-
        weightedRF_network(mats[[name]], density = density, pwm_occurrence, genes, tfs)
        lmses[,name] <- mats[[name]]["mse",]
      }
}
save(edges, file = "results/rdata/weightedRF_edges_100rep.rdata")
save(lmses, file = "results/rdata/weightedRF_mse_100rep.rdata")

# validation of GRN edges against DAP-Seq
settings <- c("model", "alpha", "dataset", "rep", "density")
val_dap <-
  evaluate_networks(
    edges,
    validation = c("DAPSeq"),
    nCores = 35,
    input_genes = genes,
    input_tfs = tfs
  )
val_dap[, settings] <-
  str_split_fixed(val_dap$network_name, '_', length(settings))
save(val_dap, file = "results/rdata/weightedRF_validation_100rep.rdata")
```

## For weightedLASSO

```{r, eval=FALSE}
nCores = 40
# mats <- list()
nrep <- 50
for(alpha in c(1)){ # exploring PWM integration strength
  for(rep in 1:nrep){ # exploring inherent variability
    
    mat_lasso <- weightedLASSO_inference(counts = counts, genes = genes, tfs = tfs,
                                     alpha = alpha, N = 50, 
                                     tf_expression_permutation = FALSE,
                                     int_pwm_noise = 0, mda_type = "shuffle",
                                     pwm_occurrence = pwm_occurrence,
                                     nCores = nCores)
    
    mat_lasso_perm <- weightedLASSO_inference(counts, genes, tfs,
                                     alpha = alpha, N = 50, 
                                     tf_expression_permutation = TRUE,
                                     int_pwm_noise = 0, mda_type = "shuffle",
                                     pwm_occurrence = pwm_occurrence,
                                     nCores = nCores)
    
    mats[[paste0("LASSO_", as.character(alpha),  '_trueData_', rep)]] <- mat_lasso
    mats[[paste0("LASSO_", as.character(alpha),  '_shuffled_', rep)]] <- mat_lasso_perm
    
  }
}

save(mats, file = "results/rdata/weightedLASSO_importances_50rep.rdata")

# thresholds the regulatory weights at certain densities to build GRNs
edges <- list()
lmses <- data.frame(row.names = genes)
densities <- c(0.005, 0.01,0.05)
for(name in names(mats)){ 
      for(density in densities){# exploring importance threshold stringency
        edges[[paste0(name, '_', density)]] <-
        weightedLASSO_network(mats[[name]], density = density, pwm_occurrence, 
                          genes, tfs, decreasing = TRUE)
        
        lmses[,name] <- mats[[name]]["mse",]
      }
}

save(edges, file = "results/rdata/weightedLASSO_edges_50rep.rdata")
save(lmses, file = "results/rdata/weightedLASSO_mse_50rep.rdata")


# validation of GRN edges against DAP-Seq
settings <- c("model", "alpha", "dataset", "rep", "density")
val_dap <-
  evaluate_networks(
    edges,
    validation = c("DAPSeq"),
    nCores = 35,
    input_genes = genes,
    input_tfs = tfs
  )
val_dap[, settings] <-
  str_split_fixed(val_dap$network_name, '_', length(settings))
save(val_dap, file = "results/rdata/weightedLASSO_validation_50rep.rdata")

```


# Gene-level optimisation of TFBM information

From the stored results, we now provide some code to examine the results and then optimize alpha.


## Plotting EDI behaviour for all genes

How does the effective data integration (EDI) vary when alpha increases?

### In weightedRF

```{r, fig.height=20}

col_fun = colorRamp2(c(1, 201), hcl_palette = "Blue-Red 3")

# loads the mats object (importance of TF-target interactions)
load("results/rdata/weightedRF_importances_100rep.rdata")


# getting mean EDI values for all genes as a function of alpha
edi_rf <- mcsapply(genes, draw_gene_effective_integration, mats = mats,
                          return=T, mc.cores=40)

edi <- t(as.data.frame(edi_rf[3,]))
colnames(edi) = ALPHAS
edi <- na.omit(edi)
ha = HeatmapAnnotation(
    alpha = anno_simple(colnames(edi)),
    annotation_name_side = "left")

rf <- Heatmap(edi, col = col_fun,
        show_column_names = T,
         width = ncol(edi)*unit(10, "mm"), 
      height = nrow(edi)*unit(0.2, "mm"),
      name = "EDI",
        cluster_columns = F, show_row_names = F)

png("results/supp_figures/EDI_all_genes_weightedRF.png", 
    res = 300, height = 1700+2200, width = 2000)
rf
dev.off()
```

### In weightedLASSO

```{r, fig.height=20}
# loads the mats object (importance of TF-target interactions)
load("results/rdata/weightedLASSO_importances_50rep.rdata")

# getting mean EDI values for all genes as a function of alpha
edi_lasso <- mcsapply(genes, draw_gene_effective_integration, mats = mats,
                          return=T, mc.cores=40)

edi <- t(as.data.frame(edi_lasso[3,]))
colnames(edi) = ALPHAS
edi <- na.omit(edi)
lasso <- Heatmap(edi, 
        col = col_fun, show_column_names = T,
         width = ncol(edi)*unit(10, "mm"), 
      height = nrow(edi)*unit(0.2, "mm"),
      name = "EDI",
        cluster_columns = F, show_row_names = F)
png("results/supp_figures/EDI_all_genes_weightedLASSO.png", 
    res = 300, height = 1700+2200, width = 2000)
lasso
dev.off()
```


## TFBM support of globally optimized networks :

```{r}
# loads lasso edges
load(file = "results/rdata/weightedLASSO_edges_50rep.rdata")
edges_num <- lapply(edges, function(df) df[sapply(df, is.numeric)])
d <- data.frame(settings = names(unlist(lapply(edges_num, FUN = nrow))),
                pwm = unlist(lapply(edges_num, FUN = colMeans)))
d[c("model", "alpha", "dataset", "rep", "density")] <- str_split_fixed(d$settings, '_', 5)
d_lasso <- d


# loads rf edges
load(file = "results/rdata/weightedRF_edges_100rep.rdata")
edges_num <- lapply(edges, function(df) df[sapply(df, is.numeric)])
d <- data.frame(settings = names(unlist(lapply(edges_num, FUN = nrow))),
                pwm = unlist(lapply(edges_num, FUN = colMeans)))
d[c("model", "alpha", "dataset", "rep", "density")] <- str_split_fixed(d$settings, '_', 5)
d <- rbind.data.frame(d, d_lasso)

# plots the TFBM support for both models :
pwm_support <- d %>%
  mutate(alpha = as.numeric(alpha),
         model = str_replace(model, "bRF", "weightedRF"),
         model = str_replace(model, "LASSO", "weightedLASSO"),
         density = paste("D =", density)) %>%
  ggplot(aes(color = dataset, x = alpha, y = pwm)) +
  geom_point() + 
  geom_smooth() +
  theme_bw()+
  ggh4x::facet_nested_wrap(vars(model, density), ncol =3, nest_line = T) + 
  theme(strip.background = element_blank(), axis.title.x = element_text(size = 22),
        title = element_text(size = 16), strip.text = element_text(size = 16), 
        legend.text = element_text(size = 15), axis.text = element_text(size = 12)) +
  xlab(expression(alpha)) + ylab("Mean of TFBM scores") + 
  scale_color_manual(values = setNames(c("grey", "#70AD47"), c("shuffled", "trueData")))+
  ggtitle("Mean of TFBM scores in inferred GRN edges") ; pwm_support
ggsave(pwm_support, file = "results/supp_figures/TFBM_support.pdf", width = 11, height = 8)
```

Wo do reach a TFBM support of 1 for $\alpha = 1$, which is the desired behavior.


## Some gene examples to illustrate our gene-specific optimization of alpha

`get_opt_alpha_per_gene` is the function returning the optimal value of $\alpha$ for one gene, or drawing the corresponding plot.
The optimal value of $\alpha$ is set to where the deviation from the shuffled baseline in terms of MSE is the greater, and if it exceeds a certain dispersion threshold.

### In weightedRF

Plots the results for the proposed gene-specific criterion for some gene examples :

```{r, fig.width=9, fig.height=8}
# loads the MSE data for weightRF
load("results/rdata/weightedRF_mse_100rep.rdata")

# loads the importances
load("results/rdata/weightedRF_importances_100rep.rdata")

gene_no_benefit <- "AT1G30270"
gene_benefit_optimum <- "AT1G14720"
gene_benefit <- "AT5G48970"

n <- draw_gene_effective_integration(gene_no_benefit, mats = mats, prior = 1) +
  draw_gene_mse(gene_no_benefit, lmses = lmses)+
  get_opt_alpha_per_gene(gene_no_benefit, mats = mats, lmses = lmses)+
  plot_annotation(title = gene_no_benefit) 
o <- draw_gene_effective_integration(gene_benefit_optimum, mats = mats, prior = 1) +
  draw_gene_mse(gene_benefit_optimum, lmses = lmses)+theme(legend.position = "none")+
  get_opt_alpha_per_gene(gene_benefit_optimum, mats = mats, lmses = lmses)+
  plot_annotation(title = gene_benefit_optimum) 
p <- draw_gene_effective_integration(gene_benefit, mats = mats, prior = 1) +
  draw_gene_mse(gene_benefit, lmses = lmses)+theme(legend.position = "none")+
  get_opt_alpha_per_gene(gene_benefit, mats = mats, lmses = lmses)+
  plot_annotation(title = gene_benefit)


figure <- n/o/p;figure
ggexport(figure, filename = "results/gene_examples_weightedRF.pdf", width = 10, height = 9)

```


Some more figures illustrating the approach on several gene cases for the ISMB 2023 talk and for the paper supp figures : 


```{r}
# mse increase (or AT5G64660)
compromise <- get_opt_alpha_per_gene("AT1G14720", mats = mats, lmses = lmses)+
  labs(subtitle = "AT1G14720")+
  get_opt_alpha_per_gene("AT5G16650", mats = mats, lmses = lmses)+
  labs(subtitle = "AT5G16650")
 

# mse decrease
ideal <- get_opt_alpha_per_gene("AT1G70790", mats = mats, lmses = lmses)+
  theme(legend.position = "right") + 
  labs(subtitle = "AT1G70790")


# mse increase_bad
bad <- get_opt_alpha_per_gene("AT1G56230", mats = mats, lmses = lmses) +
  labs(subtitle = "AT1G56230")+ 
  get_opt_alpha_per_gene("AT2G29990", mats = mats, lmses = lmses)+
  labs(subtitle = "AT2G29990")


# min mse but not our approach

lost <- get_opt_alpha_per_gene("AT1G47395", mats = mats, lmses = lmses)+
  labs(subtitle = "AT1G47395")

saved <- get_opt_alpha_per_gene("AT3G20320", mats = mats, lmses = lmses)+
  labs(subtitle = "AT3G20320")

get_opt_alpha_per_gene("AT5G43420", mats = mats, lmses = lmses)
get_opt_alpha_per_gene("AT3G07590", mats = mats, lmses = lmses)

ggexport(ideal, filename = "results/ismb_talk/wRF_ideal.pdf", width = 6, height = 5)
ggexport(compromise, filename = "results/ismb_talk/wRF_compromise.pdf", width = 10, height = 5)
ggexport(bad, filename = "results/ismb_talk/wRF_bad.pdf", width = 10, height = 5)

ggexport(lost, filename = "results/supp_figures/wRF_example_gene_lost.pdf", width = 5, height = 5)
ggexport(saved, filename = "results/supp_figures/wRF_example_gene_saved.pdf", width = 5, height = 5)


eff_data <- draw_gene_effective_integration("AT1G14720", mats = mats)+
   theme(legend.position = "right") 

ggexport(eff_data, filename = "results/ismb_talk/wRF_eff_data_int.pdf", 
         width = 6, height = 5)

mse <- draw_gene_mse("AT1G70790", lmses = lmses)+
   theme(legend.position = "right") 

ggexport(mse, filename = "results/ismb_talk/wRF_mse.pdf", 
         width = 6, height = 5)

```


After these illustrations, we returns the optimal value of alpha for all nitrate responsive genes :

```{r, eval=F}
# value of alpha per genes:
alphas_rf <- mcsapply(genes, get_opt_alpha_per_gene,
                          return_alpha=T, mc.cores=34)
save(alphas_rf, file = "results/rdata/gene_specific/alpha_per_gene_weightedRF_mean_true_shuff_sd.rdata")

# doing the same but with the value of alpha minimising the mse:
alphas_rf <- mcsapply(genes, get_opt_alpha_per_gene, metric = "min",
                          return_alpha=T, mc.cores=34)
save(alphas_rf, file = "results/rdata/gene_specific/alpha_per_gene_weightedRF_min.rdata")
```


### In weightedLASSO:


```{r fig.height=10, fig.width=10}
# loads mse and importances for weightedLASSO
load("results/rdata/weightedLASSO_mse_50rep.rdata")
load("results/rdata/weightedLASSO_importances_50rep.rdata")

n <- draw_gene_effective_integration(gene_no_benefit, mats = mats, prior = 1) +
  draw_gene_mse(gene_no_benefit, lmses = lmses)+
  get_opt_alpha_per_gene(gene_no_benefit, mats = mats, lmses = lmses)+
  plot_annotation(title = gene_no_benefit) 
o <- draw_gene_effective_integration(gene_benefit_optimum, mats = mats, prior = 1) +
  draw_gene_mse(gene_benefit_optimum, lmses = lmses)+theme(legend.position = "none")+
  get_opt_alpha_per_gene(gene_benefit_optimum, mats = mats, lmses = lmses)+
  plot_annotation(title = gene_benefit_optimum) 
p <- draw_gene_effective_integration(gene_benefit, mats = mats, prior = 1) +
  draw_gene_mse(gene_benefit, lmses = lmses)+theme(legend.position = "none")+
  get_opt_alpha_per_gene(gene_benefit, mats = mats, lmses = lmses)+
  plot_annotation(title = gene_benefit)


n/o/p
figure <- n/o/p
ggexport(figure, filename = "results/gene_examples_weightedLASSO.pdf", width = 10, height = 9)
```

Computing $\alpha$ for all genes :

```{r, eval=FALSE}
# value of alpha per genes:
alphas_lasso <- mcsapply(genes, get_opt_alpha_per_gene, mats = mats, 
                         lmses = lmses,
                          return_alpha=T, mc.cores=34)
save(alphas_lasso, file = "results/rdata/gene_specific/alpha_per_gene_weightedLASSO_mean_true_shuff_sd.rdata")

# doing the same but with the value of alpha minimising the mse:
alphas_lasso <- mcsapply(genes, get_opt_alpha_per_gene, 
                          return_alpha=T, metric = "min", mc.cores=34)
save(alphas_lasso, file = "results/rdata/gene_specific/alpha_per_gene_weightedLASSO_min.rdata")
```


## Distributions of optimal alphas

For maximal divergence from permutation criterion :

```{r}
# optimal values of alpha :
load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO_mean_true_shuff_sd.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedRF_mean_true_shuff_sd.rdata")

hists <- data.frame(weightedLASSO = alphas_lasso, 
                    weightedRF = alphas_rf) %>%
  gather(key = "model", value = "alpha") %>%
ggplot(aes(x = alpha, fill = model)) +
  geom_histogram()+
  facet_wrap(~model)+
  theme(axis.title.y = element_blank(), legend.position = "none")+
  scale_fill_manual( values = c("#C55A11","#E67F87"))+theme_bw()+
  theme(strip.background = element_blank(),
        legend.position = "none")+
  xlab(expression(alpha))+ ylab("Number of genes")
ggexport(hists, filename  = "results/alpha_histograms.pdf", height = 3, width = 7)
```



# Plotting MSE behaviour for all genes

How does the MSE change with $\alpha$? Depending on their class (optimal alpha different from 0 or not).

## weightedRF

```{r, fig.height=10}
load("results/rdata/weightedRF_mse_100rep.rdata")
load(file = "results/rdata/gene_specific/alpha_per_gene_weightedRF_mean_true_shuff_sd.rdata")

pos_class <- names(alphas_rf[alphas_rf!=0])

mse <- lmses[str_detect(colnames(lmses), "trueData")]
for(alpha in seq(0,1, by = 0.1)){
  mse[,paste("alpha",alpha)] <- rowMeans(mse[,str_detect(colnames(mse), paste0("RF_",as.character(alpha), "_"))])
}
mse <- as.matrix(mse[str_detect(colnames(mse), "alpha")])
mse_interest <- mse[pos_class,]
mse_other <- mse[setdiff(rownames(mse), pos_class),]

col_fun = colorRamp2(c(-2, 0, 2), hcl_palette = "Blue-Red 3")

ha = HeatmapAnnotation(
    alpha = anno_simple(as.numeric(str_remove(colnames(mse), "alpha "))),
    annotation_name_side = "left")

png("results/rf_mse_interest.png", res = 300, height = 1700, width = 2000)
Heatmap((mse_interest-rowMeans(mse_interest))/matrixStats::rowSds(mse_interest), 
        col = col_fun, show_column_names = F,
         width = ncol(mse_interest)*unit(10, "mm"), 
      height = nrow(mse_interest)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F)+ 
  rowAnnotation(class = ifelse(alphas_rf[rownames(mse_interest)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
png("results/rf_mse_others.png", res = 300, height = 2200, width = 2000)
Heatmap((mse_other-rowMeans(mse_other))/matrixStats::rowSds(mse_other),
        col = col_fun,show_column_names = F,
        width = ncol(mse_other)*unit(10, "mm"), 
      height = nrow(mse_other)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F)+ 
  rowAnnotation(class = ifelse(alphas_rf[rownames(mse_other)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
```

## weightedLASSO

```{r, fig.height=10}

load("results/rdata/weightedLASSO_mse_50rep.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO_mean_true_shuff_sd.rdata")


pos_class <- names(alphas_lasso[alphas_lasso!=0])

mse <- lmses[str_detect(colnames(lmses), "trueData")]
for(alpha in seq(0,1, by = 0.1)){
  mse[,paste("alpha",alpha)] <- rowMeans(mse[,str_detect(colnames(mse), paste0("LASSO_",as.character(alpha), "_"))])
}
mse <- as.matrix(mse[str_detect(colnames(mse), "alpha")])
mse_interest <- mse[pos_class,]
mse_other <- mse[setdiff(rownames(mse), pos_class),]

library(circlize)
col_fun = colorRamp2(c(-2, 0, 2), hcl_palette = "Blue-Red 3")

ha = HeatmapAnnotation(
    alpha = anno_simple(as.numeric(str_remove(colnames(mse), "alpha "))),
    annotation_name_side = "left")

png("results/lasso_mse_interest.png", res = 300, height = 2000, width = 2000)
Heatmap((mse_interest-rowMeans(mse_interest))/matrixStats::rowSds(mse_interest), 
        col = col_fun, show_column_names = F,
         width = ncol(mse_interest)*unit(10, "mm"), 
      height = nrow(mse_interest)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F)+ 
  rowAnnotation(class = ifelse(alphas_lasso[rownames(mse_interest)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
png("results/lasso_mse_others.png", res = 300, height = 2200, width = 2000)
Heatmap((mse_other-rowMeans(mse_other))/matrixStats::rowSds(mse_other),
        col = col_fun,show_column_names = F,
        width = ncol(mse_other)*unit(10, "mm"), 
      height = nrow(mse_other)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F)+ 
  rowAnnotation(class = ifelse(alphas_lasso[rownames(mse_other)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
```


# Intersection between genes with $\alpha > 1$

Are the genes with $\alpha > 1$ (the ones for which we allow TFBM integration) the same between weightedLASSO and weightedRF?

```{r}
venn <- ggVennDiagram(list("weightedRF" = names(alphas_rf[alphas_rf!=0]),
                   "weightedLASSO" = names(alphas_lasso[alphas_lasso!=0])), edge_size = 2)+ 
  scale_color_manual( values = c("#C55A11","#E67F87"))+
  scale_fill_gradient(high="#e6f2ff", low="#e6f2ff")+
  theme(legend.position = "none");venn

# hypergeometric test to assess the significance of the intersect
p_enrich <- phyper(q=351, m = length(names(alphas_rf[alphas_rf!=0])), 
                   n = length(genes) - length(names(alphas_rf[alphas_rf!=0])), 
                   k = length( names(alphas_lasso[alphas_lasso!=0])), lower.tail = F)
p_enrich
ggexport(venn, filename = "results/classes_intersection.pdf", width = 4, height = 4)
```
Not really, even though the intersection is clearly significant.

# Properties of th gene-specifically optimized GRNs

The following code chunks learns GRNs with the optimal values of alpha determined by our approach, and stores the results.

```{r, eval = F}
nCores = 34
mats <- list()
nrep <- 10
for(rep in 1:nrep){ # exploring inherent variability
  
  mat_lasso <- weightedLASSO_inference(counts, genes, tfs,
                                   alpha = alphas_lasso, N = 50,
                                   tf_expression_permutation = FALSE,
                                   int_pwm_noise = 0, mda_type = "shuffle",
                                   pwm_occurrence = pwm_occurrence,
                                   nCores = nCores)

  mat_lasso_perm <- weightedLASSO_inference(counts, genes, tfs,
                                   alpha = alphas_lasso, N = 50,
                                   tf_expression_permutation = TRUE,
                                   int_pwm_noise = 0, mda_type = "shuffle",
                                   pwm_occurrence = pwm_occurrence,
                                   nCores = nCores)

  mats[[paste0("LASSO_trueData_", rep)]] <- mat_lasso
  mats[[paste0("LASSO_shuffled_", rep)]] <- mat_lasso_perm
  
   mat_rf <- weightedRF_inference(counts, genes, tfs, nTrees = 2000,
                            alpha = alphas_rf,
                            pwm_occurrence = pwm_occurrence,
                            nCores = nCores,
                            importance = "%IncMSE")
    
    mat_rf_perm <- weightedRF_inference(counts, genes, tfs, nTrees = 2000,
                            alpha = alphas_rf, 
                            tf_expression_permutation = TRUE,
                            pwm_occurrence = pwm_occurrence,
                            nCores = nCores,
                            importance = "%IncMSE")
  
  mats[[paste0("RF_trueData_", rep)]] <- mat_rf
  mats[[paste0("RF_shuffled_", rep)]] <- mat_rf_perm
}
save(mats, file = "results/rdata/gene_specific/gene_specific_grns_mean_true_shuff_sd.rdata")


edges <- list()
lmses <- data.frame(row.names = genes)
for(name in names(mats)){ 
      for(density in c(0.005,0.01,0.05)){# exploring importance threshold stringency
        
        if(str_detect(name, "LASSO"))
          edges[[paste0(name, '_', density)]] <-
        weightedLASSO_network(mats[[name]], density = density, pwm_occurrence, 
                          genes, tfs, decreasing = TRUE)
        else
          edges[[paste0(name, '_', density)]] <-
        weightedRF_network(mats[[name]], density = density, pwm_occurrence, 
                          genes, tfs)
        lmses[,name] <- mats[[name]]["mse",]
      }
}
save(lmses, file = "results/rdata/gene_specific/gene_specific_mse_mean_true_shuff_sd.rdata") 
save(edges, file = "results/rdata/gene_specific/gene_specific_edges_mean_true_shuff_sd.rdata") 

# validation against DAP-Seq
settings <- c("model", "dataset", "rep", "density")
val_specific <-
  evaluate_networks(
    edges,
    validation = c("DAPSeq"),
    nCores = 30,
    input_genes = genes,
    input_tfs = tfs
  )
val_specific[, settings] <-
  str_split_fixed(val_specific$network_name, '_', length(settings))
save(val_specific, file = "results/rdata/gene_specific/gene_specific_validation_mean_true_shuff_sd.rdata")
```


## Precision and recall of global optimisation of alpha

The following code validates globally inferred GRNs, with a given density, against an experimental gold standard (here, DAP-Seq interactions).


```{r, fig.width=10, fig.height=10}

load(file = "results/rdata/weightedRF_validation_100rep.rdata")
val_rf <- val_dap
load(file = "results/rdata/weightedLASSO_validation_50rep.rdata")
val_lasso <- val_dap

precision_lasso <- draw_validation(validation = val_lasso)+
  plot_annotation(title = "weightedLASSO") & 
  theme(plot.title = element_text(size = 20, hjust = 0.5) )

ggexport(precision_lasso, filename = "results/supp_figures/precision_recall_weightedLASSO.pdf", 
         width = 10, height = 10)

precision_rf <- draw_validation(validation = val_rf)+
  plot_annotation(title = "weightedRF") & 
  theme(plot.title = element_text(size = 20, hjust = 0.5) )


ggexport(precision_rf, filename = "results/supp_figures/precision_recall_weightedRF.pdf", 
         width = 10, height = 10)
```


## Precision and recall of gene-specific optimisation of alpha


```{r, warning=TRUE}
settings <- c("model", "dataset", "rep", "density")

load("results/rdata/gene_specific/gene_specific_mse_mean_true_shuff_sd.rdata")
load("results/rdata/gene_specific/gene_specific_validation_mean_true_shuff_sd.rdata")

val_spec <- val_specific %>%
  separate(network_name, into = settings, sep = "_") %>%
    filter(density == 0.005) %>%
  mutate(density = paste("D =", density),
           model = str_replace(model, "RF", "weightedRF"),
           model = str_replace(model, "LASSO", "weightedLASSO"), 
         alpha_type = "gene-specific")

data_val <- rbind.data.frame(val_rf, val_lasso) %>%
    filter(density %in% c(0.005))%>%
    group_by(model, alpha, dataset, density) %>%
    mutate(mean_precision = mean(precision, na.rm = T),
           sd_precision = sd(precision, na.rm = T),
           mean_recall = mean(recall, na.rm = T),
           sd_recall = sd(recall, na.rm = T),
           density = paste("D =", density),
           model = str_replace(model, "bRF", "weightedRF"),
           model = str_replace(model, "LASSO", "weightedLASSO")) %>%
  dplyr::select(-network_name) %>%
  mutate(alpha = as.numeric(alpha), alpha_type = "global")

pr_curves <- data_val %>%
  ggplot(aes(x=recall, y=precision, 
             color = interaction(dataset, alpha_type),
             fill = interaction(dataset, alpha_type))) +
  geom_point(size = 0.65)+
  geom_ribbon(aes(ymin = mean_precision - sd_precision , 
                    ymax = mean_precision + sd_precision, x=mean_recall  ), alpha = 0.4)+
  theme_pubr()+ ggh4x::facet_nested_wrap(vars(model), nest_line = T)+
  geom_line(aes(y=mean_precision, x=mean_recall), size=2)+
  theme(strip.background = element_blank())+
  geom_hline(color = "#C55A11", yintercept = 0.331042, size= 1.5, show.legend = T) +
  geom_point(aes(x=recall, y=precision), data = val_spec)+
  scale_color_manual(name = "Dataset and type of integration",
                     values = setNames(c("lightblue", "grey", "#4670CD", "#70AD47"), 
                                       c("shuffled.gene-specific","shuffled.global",
                                         "trueData.gene-specific", "trueData.global")))+
  scale_fill_manual(name = "Dataset and type of integration",
                     values = setNames(c("lightblue", "grey", "#4670CD", "#70AD47"), 
                                       c("shuffled.gene-specific","shuffled.global",
                                         "trueData.gene-specific", "trueData.global")));pr_curves
```

## MSE, precision and recall of all networks

Summarized in one figure, including the synthetic permutations :


```{r, fig.width=12, fig.height=10}

plot_MSE_gene_specific <- function(model_){
  lmses %>%
  rownames_to_column("gene") %>%
  reshape2::melt()%>%
    separate(variable,
             into = c("model", "dataset",  "rep"),
             sep = "_") %>%
  filter(model == model_) %>%
  group_by(dataset, rep) %>%
  summarise(median_MSE = median(value, na.rm=T))%>%
    ggplot(aes(x=dataset, y = median_MSE, color = dataset, fill = dataset)) + 
  scale_color_manual(values = setNames(c("lightblue", "#4670CD"), c("shuffled", "trueData")))+
    scale_fill_manual(values = setNames(c("lightblue", "#4670CD"), c("shuffled", "trueData"))) +
  geom_boxplot(size = 1, alpha = 0.5, outlier.alpha = 0) +
  theme_pubr() + geom_jitter(width = 0.2, size = 2)+
  theme(
    strip.background = element_blank(),
    axis.title.x = element_text(size = 22),
    title = element_text(size = 16),
    axis.ticks.x = element_blank(),
    strip.text = element_text(size = 16),
    legend.text = element_text(size = 15),
    axis.text.x = element_blank(),
    legend.position = 'none'
  )+ xlab("")+ ylab("MSE")
}


# gene specific MSE
mse_lasso_spec <- plot_MSE_gene_specific("LASSO")
mse_rf_spec <- plot_MSE_gene_specific("RF")


# MSE for global alphas
draw_mse <- function(model){
data <- lmses[as.numeric(str_split_fixed(colnames(lmses), '_', 4)[,4]) <=10] %>%
rownames_to_column("gene") %>%
reshape2::melt()%>%
  separate(variable,
           into = c("model", "alpha", "dataset",  "rep"),
           sep = "_") %>%
filter(model == model) %>%
group_by(dataset, rep, alpha) %>%
summarise(median_MSE = median(value, na.rm=T))%>%
  group_by(alpha, dataset) %>%
  mutate(mean_median_mse = mean(median_MSE),
         sd_median_mse = sd(median_MSE)) %>%
  mutate(alpha = as.numeric(alpha))
data %>%
  ggplot(aes(x=alpha, y = median_MSE, color = dataset, fill = dataset)) + 
scale_color_manual(values = setNames(c("grey", "#70AD47"),
                                     c("shuffled", "trueData")))+
  scale_fill_manual(values = setNames(c("grey", "#70AD47"), 
                                      c("shuffled", "trueData"))) +
  geom_line(aes(y=mean_median_mse, group = dataset)) +
  geom_ribbon(aes(ymin = mean_median_mse - sd_median_mse , 
                    ymax = mean_median_mse + sd_median_mse), 
                alpha = .4)+ xlab(expression(alpha)) +
theme_pubr() + geom_point(width = 0.2, size = 2)+
theme(
  strip.background = element_blank(),
  axis.title.x = element_text(size = 22),
  title = element_text(size = 16),
  strip.text = element_text(size = 16),
  legend.text = element_text(size = 15),
  legend.position = 'none'
)+ ylab("MSE")
}

load("results/rdata/weightedLASSO_mse_50rep.rdata")
mse_lasso <- draw_mse("LASSO")

load("results/rdata/weightedRF_mse_100rep.rdata")
mse_rf <- draw_mse("RF")
x_min <- 0.19

plot <- (mse_lasso + ylim(c(x_min,0.265)) +labs(subtitle = "Global\ndata integration")+ 
  mse_lasso_spec+ ylim(c(x_min,0.265)) +labs(subtitle = "Gene-specific\ndata integration")+ylab("") +
  mse_rf +  ylim(c(x_min,0.265)) +labs(subtitle = "Global\ndata integration")+ ylab("") +
  mse_rf_spec+ ylim(c(x_min,0.265))  +labs(subtitle = "Gene-specific\ndata integration")+ylab(""))+
  plot_layout(guides = "collect", ncol = 4, widths = c(1.5,1,1.5,1)) & theme(legend.position = 'bottom')

ggexport(plot, filename = "results/specific_grns_mse_with_baseline.pdf", width = 11, height = 6)

plot_final <- plot/ pr_curves+theme(legend.position = "none", 
                      axis.title = element_text(size= 15),
                      strip.text = element_text(size = 18))+
  plot_layout(heights = c(1,1.5))

ggexport(plot_final, filename = "results/specific_grns_mean_true_shuff_sd.pdf", width = 11, height = 10)

```


Final figure without permutations, clearer for the article :


```{r, fig.width=12, fig.height=10}

plot_MSE_gene_specific <- function(model_){
  lmses %>%
rownames_to_column("gene") %>%
reshape2::melt()%>%
  separate(variable,
           into = c("model", "dataset",  "rep"),
           sep = "_") %>%
filter(model == model_ & dataset == "trueData") %>%
group_by(dataset , rep) %>%
summarise(median_MSE = median(value, na.rm=T))%>%
  ggplot(aes(x=dataset, y = median_MSE)) + 
geom_boxplot(size = 1, alpha = 0.5, outlier.alpha = 0, 
             color = "#4670CD", fill = "#4670CD") +
theme_pubr() + geom_jitter(width = 0.2, size = 2,  color = "#4670CD")+
theme(
  strip.background = element_blank(),
  axis.line = element_blank(), 
  axis.title=element_blank(),
  axis.text=element_blank(),
  axis.ticks=element_blank(), 
  title = element_text(size = 16),
  strip.text = element_text(size = 16),
  legend.text = element_text(size = 15),
  legend.position = 'none'
)+ xlab("")+ ylab("MSE")
}
# gene specific MSE
mse_lasso_spec <- plot_MSE_gene_specific("LASSO")
mse_rf_spec <- plot_MSE_gene_specific("RF")

# MSE for global alphas
draw_mse <- function(model){
data <- lmses[as.numeric(str_split_fixed(colnames(lmses), '_', 4)[,4]) <=10] %>%
rownames_to_column("gene") %>%
reshape2::melt()%>%
  separate(variable,
           into = c("model", "alpha", "dataset",  "rep"),
           sep = "_") %>%
filter(model == model & dataset == "trueData") %>%
group_by(dataset, rep, alpha) %>%
summarise(median_MSE = median(value, na.rm=T))%>%
  group_by(alpha, dataset) %>%
  mutate(mean_median_mse = mean(median_MSE),
         sd_median_mse = sd(median_MSE)) %>%
  mutate(alpha = as.numeric(alpha))
data %>%
  ggplot(aes(x=alpha, y = median_MSE)) + 
  geom_line(aes(y=mean_median_mse, group = dataset), color = "#70AD47") +
  geom_ribbon(aes(ymin = mean_median_mse - sd_median_mse , 
                    ymax = mean_median_mse + sd_median_mse), 
                alpha = .4, color = "#70AD47", fill = "#70AD47")+ 
  xlab(expression(alpha)) +
theme_pubr() + geom_point(width = 0.2, size = 2, color = "#70AD47")+
theme(
  strip.background = element_blank(),
  axis.title.x = element_text(size = 22),
  title = element_text(size = 16),
  strip.text = element_text(size = 16),
  legend.text = element_text(size = 15),
  legend.position = 'top'
)+ ylab("MSE")
}

load("results/rdata/weightedLASSO_mse_50rep.rdata")
mse_lasso <- draw_mse("LASSO")

load("results/rdata/weightedRF_mse_100rep.rdata")
mse_rf <- draw_mse("RF")
x_min <- 0.19


plot <- (mse_lasso + ylim(c(x_min,0.26)) +labs(title = "weightedLASSO")+ 
           theme(plot.title = element_text(hjust = 1))+
  mse_lasso_spec+ ylim(c(x_min,0.26)) +ylab("") +
  mse_rf +  ylim(c(x_min,0.26)) +labs(title = "weightedRF")+
    theme(plot.title = element_text(hjust = 0.75))+ylab("") +
  mse_rf_spec+ ylim(c(x_min,0.26)) + ylab(""))+
  plot_layout(guides = "collect", ncol = 4, widths = c(3,1,3,1)) & 
  theme(legend.position = 'bottom', legend.text = element_text(size = 15))


pr_curves <- data_val %>%
  filter(dataset == "trueData") %>%
  ggplot(aes(x=recall, y=precision, 
             label = alpha, fill = alpha_type, color = alpha_type)) +
  geom_point(size = 0.65)+
  geom_ribbon(aes(ymin = mean_precision - sd_precision , 
                    ymax = mean_precision + sd_precision, x=mean_recall  ), alpha = 0.4)+
  theme_pubr()+ ggh4x::facet_nested_wrap(vars(model), nest_line = T)+
  geom_line(aes(y=mean_precision, x=mean_recall), size=2)+
  geom_label(aes(y=mean_precision, x=mean_recall), nudge_y = 0.02, fill = "white", show.legend = F)+
  theme(strip.background = element_blank(), 
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 18))+
  geom_hline(color = "#C55A11", linetype='dashed',
             yintercept = 0.331042, size= 1.5, show.legend = T) +
  geom_point(aes(x=recall, y=precision), data = val_spec[val_spec$dataset=="trueData",])+
  scale_color_manual(name = "Data integration",
                     values = setNames(c( "#4670CD", "#70AD47"), 
                                       c("gene-specific", "global")))+
  scale_fill_manual(name = "Data integration",
                     values = setNames(c( "#4670CD", "#70AD47"), 
                                       c("gene-specific", "global")))+
  xlab("Recall") + ylab("Precision")


plot_final <- plot/ pr_curves+theme(legend.position = "bottom", 
                      axis.title = element_text(size= 15),
                      strip.text = element_text(size = 18))+
  plot_layout(heights = c(1,1));plot_final


plot_final

ggexport(plot_final, filename = "results/specific_grns_no_permutations_mean_sds.pdf", 
         width = 11, height = 10)

```

In summary, gene-specific optimization of alpha allows to minimize the MSE, while still achieving near-optimal precision and a good recall in both models.


# Comparison of our approach with the simplest minimal MSE criterion


Intersection between genes benefiting from data integration with the minimal MSE criterion.

```{r}

load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO_min.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedRF_min.rdata")

venn <- ggVennDiagram(list("weightedRF" = names(alphas_rf[alphas_rf!=0]),
                   "weightedLASSO" = names(alphas_lasso[alphas_lasso!=0])), edge_size = 2)+ 
  scale_color_manual( values = c("#C55A11","#E67F87"))+
  scale_fill_gradient(high="#e6f2ff", low="#e6f2ff")+
  theme(legend.position = "none");venn

# hypergeometric test to assess the significance of the intersect
p_enrich <- phyper(q=582, m = length(names(alphas_rf[alphas_rf!=0])), 
                   n = length(genes) - length(names(alphas_rf[alphas_rf!=0])), 
                   k = length( names(alphas_lasso[alphas_lasso!=0])), lower.tail = F)
p_enrich
ggexport(venn, filename = "results/classes_intersection_min.pdf", width = 4, height = 4)
```

Differences between the two criteria for the same model : 

```{r}
alphas_lasso_min <- alphas_lasso
alphas_rf_min <- alphas_rf

load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedRF.rdata")

alphas_lasso_div <- alphas_lasso
alphas_rf_div <- alphas_rf

saved_lasso <- setdiff(names(alphas_lasso_div[alphas_lasso_div > 0]), 
                             names(alphas_lasso_min[alphas_lasso_min > 0]))

saved_rf <- setdiff(names(alphas_rf_div[alphas_rf_div > 0]), 
                             names(alphas_rf_min[alphas_rf_min > 0]))

same_rf <- intersect(names(alphas_rf_div[alphas_rf_div > 0]), 
                             names(alphas_rf_min[alphas_rf_min > 0]))

lost_lasso <- setdiff(names(alphas_lasso_min[alphas_lasso_min > 0]),
                            names(alphas_lasso_div[alphas_lasso_div > 0]))

lost_rf <- setdiff(names(alphas_rf_min[alphas_rf_min > 0]),
                         names(alphas_rf_div[alphas_rf_div > 0]))

same_lasso <- intersect(names(alphas_lasso_min[alphas_lasso_min > 0]),
                        names(alphas_lasso_div[alphas_lasso_div > 0]))

matrix(c(length(same_lasso), length(lost_lasso), length(saved_lasso), 
         length(genes) - length(same_lasso) - length(lost_lasso) - length(saved_lasso)), 
       nrow = 2, byrow = F, dimnames = list(c("data integration div", "no data integration div"),
                                            c("data integration min", "no data integration min")))


```

For the RFs :

```{r}
matrix(c(length(same_rf), length(lost_rf), length(saved_rf), 
         length(genes) - length(same_rf) - length(lost_rf) - length(saved_rf)), 
       nrow = 2, byrow = F, dimnames = list(c("data integration div", "no data integration div"),
                                            c("data integration min", "no data integration min")))
```


## MSE, precision and recall analysis


```{r, fig.width=10}
load("results/rdata/gene_specific/gene_specific_validation_min.rdata")
val_specific_min <- val_specific %>%
  mutate(criterion = "min MSE")
load("results/rdata/gene_specific/gene_specific_validation_mean_true_shuff_sd.rdata")
val_specific_dev <- val_specific%>%
  mutate(criterion = "proposed approach")

precision_recall_min_dev <- rbind.data.frame(val_specific_dev, val_specific_min) %>%
  filter(dataset == "trueData" & density < 0.05) %>%
  mutate(model = paste0("weighted", model),
         density = paste0("D = ", density)) %>%
  ggplot(aes(y = precision, x = recall, color = criterion, label = density)) + 
  geom_jitter()+
  facet_nested_wrap(vars(density, model), ncol = 2, scales = "free") + theme_bw()+
  theme(strip.background = element_blank()) +
  stat_ellipse() + ggtitle("Precision and recall")
```



```{r, fig.width = 10, fig.height=5}
load("results/rdata/gene_specific/gene_specific_mse_min.rdata")
mse_min <- lmses
colnames(mse_min) <- paste0(colnames(mse_min), '_min')
mse_min$genes <- rownames(mse_min)

load("results/rdata/gene_specific/gene_specific_mse_mean_true_shuff_sd.rdata")
mse_dev <- lmses
colnames(mse_dev) <- paste0(colnames(mse_dev), '_dev')
mse_dev$genes <- rownames(mse_dev)


mse_plot <- full_join(mse_dev, mse_min, by = c("genes"))  %>%
reshape2::melt()%>%
  separate(variable,
           into = c("model", "dataset",  "rep", "criterion"),
           sep = "_") %>%
filter(dataset == "trueData") %>%
group_by(rep, model, criterion) %>%
summarise(median_MSE = median(value, na.rm=T))%>%
  mutate(criterion = str_replace(criterion, "min", "min MSE"),
         criterion = str_replace(criterion, "dev", "proposed\napproach"),
         model = paste0("weighted", model)) %>%
  ggplot(aes(x=criterion, y = median_MSE, color = criterion, fill = criterion)) +
  geom_jitter(show.legend = F)+ ylab("Median MSE") + xlab("") +
  facet_nested_wrap(vars(model), nest_line = T) +
  theme_bw() + theme(strip.background = element_blank(), 
                     legend.position = "none") +
  ggtitle("Median MSE")

min_dev_plot <- mse_plot + precision_recall_min_dev + 
  plot_layout(guides = "collect", widths = c(1.5,2)) & 
  theme(legend.position = "bottom") 


ggexport(min_dev_plot, filename = "results/supp_figures/min_mse_comparison.pdf", width = 10, height = 5)
```



# Nitrate signalling analysis


GRNs to be studied and compared (global versus gene-specific for the two models) :

```{r}
load("results/rdata/gene_specific/gene_specific_edges_mean_true_shuff_sd.rdata")

annot <- DIANE::get_gene_information(genes,organism = "Arabidopsis thaliana")

rf_nets <- names(edges)[str_detect(names(edges),"RF_trueData") ]
rf_nets <- edges[rf_nets[str_detect(rf_nets,"0.005") ]]


lasso_nets <- names(edges)[str_detect(names(edges),"LASSO_trueData") ]
lasso_nets <- edges[lasso_nets[str_detect(lasso_nets,"0.005") ]]

load(file = "results/rdata/weightedLASSO_edges_50rep.rdata")

lasso_nets_0 <- names(edges)[str_detect(names(edges),"LASSO_0_trueData") ]
lasso_nets_0 <- edges[lasso_nets_0[str_detect(lasso_nets_0,"0.005") ]]

lasso_nets_1 <- names(edges)[str_detect(names(edges),"LASSO_1_trueData") ]
lasso_nets_1 <- edges[lasso_nets_1[str_detect(lasso_nets_1,"0.005") ]]


load(file = "results/rdata/weightedRF_edges_100rep.rdata")

rf_nets_0 <- names(edges)[str_detect(names(edges),"RF_0_trueData") ]
rf_nets_0 <- edges[rf_nets_0[str_detect(rf_nets_0,"0.005") ]]

rf_nets_1 <- names(edges)[str_detect(names(edges),"RF_1_trueData") ]
rf_nets_1 <- edges[rf_nets_1[str_detect(rf_nets_1,"0.005") ]]

```


Rankings in global alpha networks compared to alpha specific in RF:

```{r}

ranks_rf <- get_hubs(rf_nets_0)$ranking+ ggtitle("weightedRF alpha = 0") + 
  theme(legend.position = "none")+
  get_hubs(rf_nets_1)$ranking+ggtitle("weightedRF alpha = 1") + 
  theme(legend.position = "none")+
  get_hubs(rf_nets)$ranking+ ggtitle("weightedRF gene-specific alpha")+
  theme(legend.position = "top", legend.text = element_text(size = 15))+
  plot_layout(guides = "collect") 

# ranks_rf <- get_hubs(rf_nets)$ranking+ ggtitle("weightedRF, gene-specific optimsation")+
#   theme(legend.position = "right", legend.text = element_text(size = 15))

ggexport(ranks_rf, filename = "results/supp_figures/weightedRF_ranks_grns.pdf", width = 20, hight = 7)
# regulators in the top ranking of all GRNs
common_rf <- intersect(get_hubs(rf_nets)$top25 , union(get_hubs(rf_nets_0)$top25,
                                        get_hubs(rf_nets_1)$top25))

# regulators in gene-specific GRNs only
setdiff(get_hubs(rf_nets)$top25 , union(get_hubs(rf_nets_0)$top25,
                                        get_hubs(rf_nets_1)$top25))

```

Rankings in global alpha networks compared for alpha specific in LASSO:

```{r}
ranks_lasso <- get_hubs(lasso_nets_0)$ranking+ ggtitle("weightedLASSO alpha = 0") +
  theme(legend.position = "none")+
  get_hubs(lasso_nets_1)$ranking+ggtitle("weightedLASSO alpha = 1") +
  theme(legend.position = "none")+
  get_hubs(lasso_nets)$ranking+ ggtitle("weightedLASSO gene-specific alpha")+
  theme(legend.position = "top", legend.text = element_text(size = 15))+
  plot_layout(guides = "collect") 

ggexport(ranks_lasso, filename = "results/supp_figures/weightedLASSO_ranks_grns.pdf", width = 20, hight = 7)


# regulators in the top ranking of all GRNs
common_lasso <- intersect(get_hubs(lasso_nets)$top25 , union(get_hubs(lasso_nets_0)$top25,
                                        get_hubs(lasso_nets_1)$top25))

# regulators that were not in the top 25
setdiff(get_hubs(lasso_nets)$top25 , 
        union(get_hubs(lasso_nets_0)$top25,
              get_hubs(lasso_nets_1)$top25))
```

Regulators that are in all top connected genes :

```{r}
intersect(common_lasso, common_rf)
```


# Study of the genes with $\alpha > 1$ or $\alpha = 1$ in both models

Can we find TFBMs significantly enriched in the promoters of genes benefitting from data integration?

```{r}
load("rdata/pwm_prom_jaspar_dap.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO_mean_true_shuff_sd.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedRF_mean_true_shuff_sd.rdata")

pos_class_rf <- names(alphas_rf[alphas_rf!=0])
pos_class_lasso <- names(alphas_lasso[alphas_lasso!=0])
common <- intersect(pos_class_lasso, pos_class_rf)


neg_class_rf <- names(alphas_rf[alphas_rf==0])
neg_class_lasso <- names(alphas_lasso[alphas_lasso==0])
neg_common <- intersect(neg_class_lasso, neg_class_rf)

known_tfs <- tfs[which(tfs %in% pwm_prom$TF)]
#known_tfs <- unique(pwm_prom$TF) # to look for all TFs, not only nitrate responsive

get_number_of_motifs_per_tfs <- function(genes){
  table(pwm_prom[pwm_prom$target %in% genes &
                   pwm_prom$TF %in% tfs,"TF"])[known_tfs]
  # table(pwm_prom[pwm_prom$target %in% genes,"TF"])[known_tfs]  # to look for all TFs, not only nitrate responsive
}

get_motif_enrichment <- function(gene_list){
  enrichments_per_pwm <- setNames(rep(1, length(known_tfs)), known_tfs)
  n_targets_lasso_in_all <- get_number_of_motifs_per_tfs(genes)
  n_targets_lasso_in_group <- get_number_of_motifs_per_tfs(gene_list)
  n_group_lasso <- length(gene_list)
  
  for(tf in known_tfs){
    
    # number of genes with that motif in all genes
    n_targets_in_all_tf <- n_targets_lasso_in_all[tf]
    
    # number of genes with that motif in the lasso group
    n_targets_lasso_in_group_tf <- n_targets_lasso_in_group[tf]
    p_lasso <- phyper(q=n_targets_lasso_in_group_tf-1,
           m=n_targets_in_all_tf, #white balls
           n=length(genes)-n_targets_in_all_tf, # black balls
           k=n_group_lasso, lower.tail = FALSE)
    
    
    enrichments_per_pwm[tf]<- p_lasso
  }
  enriched_tfs <- names(which(enrichments_per_pwm < 0.05))
  all_infos <- DIANE::get_gene_information(enriched_tfs, 
                                           organism = "Arabidopsis thaliana")
  all_infos$pvalue <- enrichments_per_pwm[enriched_tfs]
  return(all_infos)
  
}

write.table(get_motif_enrichment(common), sep = '\t', row.names = T, col.names = T,
            quote = F,
            file = "results/supp_tables/enriched_TFBMs_high_alpha.tsv")

write.table(get_motif_enrichment(neg_common), sep = '\t', row.names = T, col.names = T,
            quote = F,
            file = "results/supp_tables/enriched_TFBMs_zero_alpha.tsv")
```

Looking at other potentially enriched characteristics of these genes on which we integrate TFBM :

```{r, fig.width=15, fig.height=15}
load("rdata/gene_structure.rdata")

# building the dataframe with gene functional informations

mean_expr <- rowMeans(counts)[genes]
var_expr <- matrixStats::rowSds(counts[genes,])*matrixStats::rowSds(counts[genes,])
pwm_prom_n_TFs <- pwm_prom[pwm_prom$TF %in% tfs,]
genes_info <- data.frame(genes = genes,
                         RF = factor(alphas_rf),
                         LASSO = factor(alphas_lasso))
genes_info$is_tf <- genes %in% tfs
genes_info$expression_variance <- log(var_expr+min(var_expr)*0.75)
genes_info$expression <- log(mean_expr+min(mean_expr)*0.75)
genes_info$nb_motifs <- table(pwm_prom$target)[genes]
genes_info$nb_motifs_n_tfs <- table(pwm_prom_n_TFs$target)[genes]
genes_info$common <- ifelse(genes %in% common, "alpha > 0 in\nboth models", "other genes") 
genes_info$never <- ifelse(genes_info$RF == 0 & genes_info$LASSO == 0, 
                           "alpha = 0 in\nboth models", "other genes") 
genes_info[,c("nb_introns", "nb_transcripts")] <-
  gene_structure[match(genes_info$gene, gene_structure$gene),
                 c("n_introns", "n_transcripts")]

# load("results/rdata/weightedRF_mse_100rep.rdata")
# genes_info$mse_weightedRF <- rowMeans(lmses[str_detect(colnames(lmses[genes,]), "_0_trueData")])
# load("results/lasso_perumtations_mse_all_genes_test.rdata")
# genes_info$mse_weightedLASSO <- rowMeans(lmses[str_detect(colnames(lmses[genes,]), "_0_trueData")])

# plotting each characteristics
always_plot <- genes_info %>%
  reshape2::melt() %>%
  ggplot(aes(x=factor(common), y = value, color = common)) +
  geom_jitter() + geom_boxplot(width=0.5) +
  facet_nested_wrap(vars(variable), nest_line = T, ncol = 3, scales = 'free')+
  theme_bw() + theme(strip.background = element_blank()) +
  stat_compare_means() + xlab("")+
  scale_color_brewer(palette = "Accent") +
  ggtitle("Genes for which TFBM are \nintegrated in both models")


# plotting each characteristics
never_plot <- genes_info %>%
  reshape2::melt() %>%
  ggplot(aes(x=factor(never), y = value, color = never)) +
  geom_jitter() + geom_boxplot(width=0.5) +
  facet_nested_wrap(vars(variable), nest_line = T, ncol = 3, scales = 'free')+
  theme_bw() + theme(strip.background = element_blank()) +
  stat_compare_means() + xlab("")+
  scale_color_brewer(palette = "Accent")+
  ggtitle("Genes for which TFBM are \nnot integrated in any model")

never <- genes_info[genes_info$never != "other genes",]$genes

# enrichment of TFs
pval <- phyper(q=length(intersect(common, tfs)), 
       m = length(tfs), 
       n = length(genes) - length(tfs),
       k = length(common),lower.tail = F)

TFs_always <- genes_info %>%
  group_by(common) %>%
  summarise(n=n(),
            tf_frac=sum(is_tf)/n()) %>%
  ggplot(aes(x=common, y=tf_frac,
                          label = paste("n=",n))) +
  geom_bar(stat = "identity", aes(fill=common), alpha = 1)+
  geom_hline(yintercept = length(tfs)/length(genes)) +
  scale_fill_brewer(palette = "Accent")+
  geom_text(y=0.2) + xlab("cluster RF") + theme_bw() + xlab("")+
  ggtitle(paste("Fraction of TFs, TFBM always integrated. \nHypergeometric test pvalue :", round(pval, 3)))+ylim(c(0,0.2))


# enrichment of TFs
pval <- phyper(q=length(intersect(never, tfs)), 
       m = length(tfs), 
       n = length(genes) - length(tfs),
       k = length(never), lower.tail = F)

TFs_never <- genes_info %>%
  group_by(never) %>%
  summarise(n=n(),
            tf_frac=sum(is_tf)/n()) %>%
  ggplot(aes(x=never, y=tf_frac,
                          label = paste("n=",n))) +
  geom_bar(stat = "identity", aes(fill=never), alpha = 1)+
  geom_hline(yintercept = length(tfs)/length(genes)) +
  geom_text(y=0.2) + theme_bw() + xlab("")+
  scale_fill_brewer(palette = "Accent")+
  ggtitle(paste("Fraction of TFs, TFBM never integrated. \nHypergeometric test pvalue :", 
                round(pval, 3)))+ylim(c(0,0.2))

charact <- always_plot + theme(legend.position = "none") + 
  never_plot + theme(legend.position = "none")+ 
  TFs_always +theme(legend.position = "none")+  TFs_never +theme(legend.position = "none")+ 
  plot_layout(ncol = 2, heights = c(3,1));charact

ggexport(charact, width = 14, height = 12, 
         filename = "results/supp_figures/genes_characteristics_TFBM_integration.pdf")
```

Are some biological functions enriched in the genes for which we always or never perform data integration?

```{r}
# Gene ontology enrichment
library(DIANE)

go <- enrich_go(convert_from_agi(common), convert_from_agi(genes), 
                GO_type = "BP", fdr = 0.1)

go <- enrich_go(convert_from_agi(never), 
                convert_from_agi(genes), GO_type = "BP", fdr = 0.1)
```


Expression profile of these groups of genes :


```{r}
Heatmap(counts[genes,]/rowMeans(counts[genes,]), cluster_columns = F)
Heatmap(counts[common,]/rowMeans(counts[common,]), cluster_columns = F)
Heatmap(counts[never,]/rowMeans(counts[never,]), cluster_columns = F)
```




