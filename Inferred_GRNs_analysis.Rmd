---
title: "Gene-specific tuning of integrative GRN inference : analysing inferred GRNs (MSE, precision and recall)"
output: 
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F, fig.width = 10)

source('inference_functions/weightedRF.R')
source('inference_functions/weightedLASSO.R')
source('inference_functions/evaluateNetwork.R')
source('inference_functions/data_integration_optimization.R')

library(ggplot2)
library(tidyverse)
library(ggpubr)
library(patchwork)
library(ggVennDiagram)
library(ComplexHeatmap)
library(clusterProfiler)
library(circlize)
```

This document loads the results generated by `Gene_specific_optimisation_of_TFBM_integration.Rmd` and studies the inferred GRNs. In particular, it displays the behavior of effective data integration, MSE, TFBM support as alpha increases, and also displays precision and recall analyses of inferred GRNs against DAP-Seq interactions. It can be used to reproduce the main figures of the paper.

# Data import

Import of the expression data and binding motifs data for the nitrate-responsive genes and regulators :

```{r}
load('rdata/inference_input_N_response_varala.rdata')
genes <- input_data$grouped_genes; length(genes)
tfs <- input_data$grouped_regressors; length(tfs)
counts <- input_data$counts; dim(counts)
load("rdata/pwm_occurrences_N_response_varala.rdata")
dim(pwm_occurrence)

ALPHAS <- seq(0,1, by = 0.1)
```


# Showing GRN results for a global optimisation of alpha

From the stored results, we now provide some code to examine the results.

## Plotting EDI behaviour for all genes

How does the effective data integration (EDI) vary when alpha increases?

### In weightedRF

```{r, fig.height=20}

col_fun = colorRamp2(c(1, 201), hcl_palette = "Blue-Red 3")

# loads the mats object (importance of TF-target interactions)
load("results/rdata/weightedRF_importances_100rep.rdata")


# getting mean EDI values for all genes as a function of alpha
edi_rf <- mcsapply(genes, draw_gene_effective_integration, mats = mats,
                          return=T, mc.cores=40)

edi <- t(as.data.frame(edi_rf[3,]))
colnames(edi) = ALPHAS
edi <- na.omit(edi)
ha = HeatmapAnnotation(
    alpha = anno_simple(colnames(edi)),
    annotation_name_side = "left")

rf <- Heatmap(edi, col = col_fun,
        show_column_names = T,
         width = ncol(edi)*unit(10, "mm"), 
      height = nrow(edi)*unit(0.2, "mm"),
      name = "EDI",
        cluster_columns = F, show_row_names = F)

png("results/supp_figures/EDI_all_genes_weightedRF.png", 
    res = 300, height = 1700+2200, width = 2000)
rf
dev.off()
```

### In weightedLASSO

```{r, fig.height=20}
# loads the mats object (importance of TF-target interactions)
load("results/rdata/weightedLASSO_importances_50rep.rdata")

# getting mean EDI values for all genes as a function of alpha
edi_lasso <- mcsapply(genes, draw_gene_effective_integration, mats = mats,
                          return=T, mc.cores=40)

edi <- t(as.data.frame(edi_lasso[3,]))
colnames(edi) = ALPHAS
edi <- na.omit(edi)
lasso <- Heatmap(edi, 
        col = col_fun, show_column_names = T,
         width = ncol(edi)*unit(10, "mm"), 
      height = nrow(edi)*unit(0.2, "mm"),
      name = "EDI",
        cluster_columns = F, show_row_names = F)
png("results/supp_figures/EDI_all_genes_weightedLASSO.png", 
    res = 300, height = 1700+2200, width = 2000)
lasso
dev.off()
```


## TFBM support of globally optimized networks :

```{r}
# loads lasso edges
load(file = "results/rdata/weightedLASSO_edges_50rep.rdata")
edges_num <- lapply(edges, function(df) df[sapply(df, is.numeric)])
d <- data.frame(settings = names(unlist(lapply(edges_num, FUN = nrow))),
                pwm = unlist(lapply(edges_num, FUN = colMeans)))
d[c("model", "alpha", "dataset", "rep", "density")] <- str_split_fixed(d$settings, '_', 5)
d_lasso <- d


# loads rf edges
load(file = "results/rdata/weightedRF_edges_100rep.rdata")
edges_num <- lapply(edges, function(df) df[sapply(df, is.numeric)])
d <- data.frame(settings = names(unlist(lapply(edges_num, FUN = nrow))),
                pwm = unlist(lapply(edges_num, FUN = colMeans)))
d[c("model", "alpha", "dataset", "rep", "density")] <- str_split_fixed(d$settings, '_', 5)
d <- rbind.data.frame(d, d_lasso)

# plots the TFBM support for both models :
pwm_support <- d %>%
  mutate(alpha = as.numeric(alpha),
         model = str_replace(model, "bRF", "weightedRF"),
         model = str_replace(model, "LASSO", "weightedLASSO"),
         density = paste("D =", density)) %>%
  ggplot(aes(color = dataset, x = alpha, y = pwm)) +
  geom_point() + 
  geom_smooth() +
  theme_bw()+
  ggh4x::facet_nested_wrap(vars(model, density), ncol =3, nest_line = T) + 
  theme(strip.background = element_blank(), axis.title.x = element_text(size = 22),
        title = element_text(size = 16), strip.text = element_text(size = 16), 
        legend.text = element_text(size = 15), axis.text = element_text(size = 12)) +
  xlab(expression(alpha)) + ylab("Mean of TFBM scores") + 
  scale_color_manual(values = setNames(c("grey", "#70AD47"), c("shuffled", "trueData")))+
  ggtitle("Mean of TFBM scores in inferred GRN edges") ; pwm_support
ggsave(pwm_support, file = "results/supp_figures/TFBM_support.pdf", width = 11, height = 8)
```

Wo do reach a TFBM support of 1 for $\alpha = 1$, which is the desired behavior.


## Distributions of optimal alphas

How is distributed the optimal value of TFBM integration across all nitrate responsive genes?

```{r}
# optimal values of alpha :
load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO_mean_true_shuff_sd.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedRF_mean_true_shuff_sd.rdata")

hists <- data.frame(weightedLASSO = alphas_lasso, 
                    weightedRF = alphas_rf) %>%
  gather(key = "model", value = "alpha") %>%
ggplot(aes(x = alpha, fill = model)) +
  geom_histogram()+
  facet_wrap(~model)+
  theme(axis.title.y = element_blank(), legend.position = "none")+
  scale_fill_manual( values = c("#C55A11","#E67F87"))+theme_bw()+
  theme(strip.background = element_blank(),
        legend.position = "none")+
  xlab(expression(alpha))+ ylab("Number of genes")
ggexport(hists, filename  = "results/alpha_histograms.pdf", height = 3, width = 7)
```


# Plotting MSE behaviour for all genes

How does the MSE change with $\alpha$? Depending on their class (optimal alpha different from 0 or not).

## weightedRF

```{r, fig.height=10}
load("results/rdata/weightedRF_mse_100rep.rdata")
load(file = "results/rdata/gene_specific/alpha_per_gene_weightedRF_mean_true_shuff_sd.rdata")

pos_class <- names(alphas_rf[alphas_rf!=0])

mse <- lmses[str_detect(colnames(lmses), "trueData")]
for(alpha in seq(0,1, by = 0.1)){
  mse[,paste("alpha",alpha)] <- rowMeans(mse[,str_detect(colnames(mse), paste0("RF_",as.character(alpha), "_"))])
}
mse <- as.matrix(mse[str_detect(colnames(mse), "alpha")])
mse_interest <- mse[pos_class,]
mse_other <- mse[setdiff(rownames(mse), pos_class),]

col_fun = colorRamp2(c(-2, 0, 2), hcl_palette = "Blue-Red 3")

ha = HeatmapAnnotation(
    alpha = anno_simple(as.numeric(str_remove(colnames(mse), "alpha "))),
    annotation_name_side = "left")

png("results/rf_mse_interest.png", res = 300, height = 1700, width = 2000)
Heatmap((mse_interest-rowMeans(mse_interest))/matrixStats::rowSds(mse_interest), 
        col = col_fun, show_column_names = F,
         width = ncol(mse_interest)*unit(10, "mm"), 
      height = nrow(mse_interest)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F)+ 
  rowAnnotation(class = ifelse(alphas_rf[rownames(mse_interest)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
png("results/rf_mse_others.png", res = 300, height = 2200, width = 2000)
Heatmap((mse_other-rowMeans(mse_other))/matrixStats::rowSds(mse_other),
        col = col_fun,show_column_names = F,
        width = ncol(mse_other)*unit(10, "mm"), 
      height = nrow(mse_other)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F)+ 
  rowAnnotation(class = ifelse(alphas_rf[rownames(mse_other)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
```

## weightedLASSO

```{r, fig.height=10}

load("results/rdata/weightedLASSO_mse_50rep.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO_mean_true_shuff_sd.rdata")


pos_class <- names(alphas_lasso[alphas_lasso!=0])

mse <- lmses[str_detect(colnames(lmses), "trueData")]
for(alpha in seq(0,1, by = 0.1)){
  mse[,paste("alpha",alpha)] <- rowMeans(mse[,str_detect(colnames(mse), paste0("LASSO_",as.character(alpha), "_"))])
}
mse <- as.matrix(mse[str_detect(colnames(mse), "alpha")])
mse_interest <- mse[pos_class,]
mse_other <- mse[setdiff(rownames(mse), pos_class),]

library(circlize)
col_fun = colorRamp2(c(-2, 0, 2), hcl_palette = "Blue-Red 3")

ha = HeatmapAnnotation(
    alpha = anno_simple(as.numeric(str_remove(colnames(mse), "alpha "))),
    annotation_name_side = "left")

png("results/lasso_mse_interest.png", res = 300, height = 2000, width = 2000)
Heatmap((mse_interest-rowMeans(mse_interest))/matrixStats::rowSds(mse_interest), 
        col = col_fun, show_column_names = F,
         width = ncol(mse_interest)*unit(10, "mm"), 
      height = nrow(mse_interest)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F)+ 
  rowAnnotation(class = ifelse(alphas_lasso[rownames(mse_interest)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
png("results/lasso_mse_others.png", res = 300, height = 2200, width = 2000)
Heatmap((mse_other-rowMeans(mse_other))/matrixStats::rowSds(mse_other),
        col = col_fun,show_column_names = F,
        width = ncol(mse_other)*unit(10, "mm"), 
      height = nrow(mse_other)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F)+ 
  rowAnnotation(class = ifelse(alphas_lasso[rownames(mse_other)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
```



# Properties of inferred GRNs

## Precision and recall of global optimisation of alpha

The following code validates globally inferred GRNs, with a given density, against an experimental gold standard (here, DAP-Seq interactions).


```{r, fig.width=10, fig.height=10}

load(file = "results/rdata/weightedRF_validation_100rep.rdata")
val_rf <- val_dap
load(file = "results/rdata/weightedLASSO_validation_50rep.rdata")
val_lasso <- val_dap

precision_lasso <- draw_validation(validation = val_lasso)+
  plot_annotation(title = "weightedLASSO") & 
  theme(plot.title = element_text(size = 20, hjust = 0.5) )

ggexport(precision_lasso, filename = "results/supp_figures/precision_recall_weightedLASSO.pdf", 
         width = 10, height = 10)

precision_rf <- draw_validation(validation = val_rf)+
  plot_annotation(title = "weightedRF") & 
  theme(plot.title = element_text(size = 20, hjust = 0.5) )


ggexport(precision_rf, filename = "results/supp_figures/precision_recall_weightedRF.pdf", 
         width = 10, height = 10)
```


## Precision and recall of gene-specific optimisation of alpha


```{r, warning=TRUE}
settings <- c("model", "dataset", "rep", "density")

load("results/rdata/gene_specific/gene_specific_mse_mean_true_shuff_sd.rdata")
load("results/rdata/gene_specific/gene_specific_validation_mean_true_shuff_sd.rdata")

val_spec <- val_specific %>%
  separate(network_name, into = settings, sep = "_") %>%
    filter(density == 0.005) %>%
  mutate(density = paste("D =", density),
           model = str_replace(model, "RF", "weightedRF"),
           model = str_replace(model, "LASSO", "weightedLASSO"), 
         alpha_type = "gene-specific")

data_val <- rbind.data.frame(val_rf, val_lasso) %>%
    filter(density %in% c(0.005))%>%
    group_by(model, alpha, dataset, density) %>%
    mutate(mean_precision = mean(precision, na.rm = T),
           sd_precision = sd(precision, na.rm = T),
           mean_recall = mean(recall, na.rm = T),
           sd_recall = sd(recall, na.rm = T),
           density = paste("D =", density),
           model = str_replace(model, "bRF", "weightedRF"),
           model = str_replace(model, "LASSO", "weightedLASSO")) %>%
  dplyr::select(-network_name) %>%
  mutate(alpha = as.numeric(alpha), alpha_type = "global")

pr_curves <- data_val %>%
  ggplot(aes(x=recall, y=precision, 
             color = interaction(dataset, alpha_type),
             fill = interaction(dataset, alpha_type))) +
  geom_point(size = 0.65)+
  geom_ribbon(aes(ymin = mean_precision - sd_precision , 
                    ymax = mean_precision + sd_precision, x=mean_recall  ), alpha = 0.4)+
  theme_pubr()+ ggh4x::facet_nested_wrap(vars(model), nest_line = T)+
  geom_line(aes(y=mean_precision, x=mean_recall), size=2)+
  theme(strip.background = element_blank())+
  geom_hline(color = "#C55A11", yintercept = 0.331042, size= 1.5, show.legend = T) +
  geom_point(aes(x=recall, y=precision), data = val_spec)+
  scale_color_manual(name = "Dataset and type of integration",
                     values = setNames(c("lightblue", "grey", "#4670CD", "#70AD47"), 
                                       c("shuffled.gene-specific","shuffled.global",
                                         "trueData.gene-specific", "trueData.global")))+
  scale_fill_manual(name = "Dataset and type of integration",
                     values = setNames(c("lightblue", "grey", "#4670CD", "#70AD47"), 
                                       c("shuffled.gene-specific","shuffled.global",
                                         "trueData.gene-specific", "trueData.global")));pr_curves
```

## MSE, precision and recall of all networks

Summarized in one figure, including the synthetic permutations :


```{r, fig.width=12, fig.height=10}

plot_MSE_gene_specific <- function(model_){
  lmses %>%
  rownames_to_column("gene") %>%
  reshape2::melt()%>%
    separate(variable,
             into = c("model", "dataset",  "rep"),
             sep = "_") %>%
  filter(model == model_) %>%
  group_by(dataset, rep) %>%
  summarise(median_MSE = median(value, na.rm=T))%>%
    ggplot(aes(x=dataset, y = median_MSE, color = dataset, fill = dataset)) + 
  scale_color_manual(values = setNames(c("lightblue", "#4670CD"), c("shuffled", "trueData")))+
    scale_fill_manual(values = setNames(c("lightblue", "#4670CD"), c("shuffled", "trueData"))) +
  geom_boxplot(size = 1, alpha = 0.5, outlier.alpha = 0) +
  theme_pubr() + geom_jitter(width = 0.2, size = 2)+
  theme(
    strip.background = element_blank(),
    axis.title.x = element_text(size = 22),
    title = element_text(size = 16),
    axis.ticks.x = element_blank(),
    strip.text = element_text(size = 16),
    legend.text = element_text(size = 15),
    axis.text.x = element_blank(),
    legend.position = 'none'
  )+ xlab("")+ ylab("MSE")
}


# gene specific MSE
mse_lasso_spec <- plot_MSE_gene_specific("LASSO")
mse_rf_spec <- plot_MSE_gene_specific("RF")


# MSE for global alphas
draw_mse <- function(model){
data <- lmses[as.numeric(str_split_fixed(colnames(lmses), '_', 4)[,4]) <=10] %>%
rownames_to_column("gene") %>%
reshape2::melt()%>%
  separate(variable,
           into = c("model", "alpha", "dataset",  "rep"),
           sep = "_") %>%
filter(model == model) %>%
group_by(dataset, rep, alpha) %>%
summarise(median_MSE = median(value, na.rm=T))%>%
  group_by(alpha, dataset) %>%
  mutate(mean_median_mse = mean(median_MSE),
         sd_median_mse = sd(median_MSE)) %>%
  mutate(alpha = as.numeric(alpha))
data %>%
  ggplot(aes(x=alpha, y = median_MSE, color = dataset, fill = dataset)) + 
scale_color_manual(values = setNames(c("grey", "#70AD47"),
                                     c("shuffled", "trueData")))+
  scale_fill_manual(values = setNames(c("grey", "#70AD47"), 
                                      c("shuffled", "trueData"))) +
  geom_line(aes(y=mean_median_mse, group = dataset)) +
  geom_ribbon(aes(ymin = mean_median_mse - sd_median_mse , 
                    ymax = mean_median_mse + sd_median_mse), 
                alpha = .4)+ xlab(expression(alpha)) +
theme_pubr() + geom_point(width = 0.2, size = 2)+
theme(
  strip.background = element_blank(),
  axis.title.x = element_text(size = 22),
  title = element_text(size = 16),
  strip.text = element_text(size = 16),
  legend.text = element_text(size = 15),
  legend.position = 'none'
)+ ylab("MSE")
}

load("results/rdata/weightedLASSO_mse_50rep.rdata")
mse_lasso <- draw_mse("LASSO")

load("results/rdata/weightedRF_mse_100rep.rdata")
mse_rf <- draw_mse("RF")
x_min <- 0.19

plot <- (mse_lasso + ylim(c(x_min,0.265)) +labs(subtitle = "Global\ndata integration")+ 
  mse_lasso_spec+ ylim(c(x_min,0.265)) +labs(subtitle = "Gene-specific\ndata integration")+ylab("") +
  mse_rf +  ylim(c(x_min,0.265)) +labs(subtitle = "Global\ndata integration")+ ylab("") +
  mse_rf_spec+ ylim(c(x_min,0.265))  +labs(subtitle = "Gene-specific\ndata integration")+ylab(""))+
  plot_layout(guides = "collect", ncol = 4, widths = c(1.5,1,1.5,1)) & theme(legend.position = 'bottom')

ggexport(plot, filename = "results/specific_grns_mse_with_baseline.pdf", width = 11, height = 6)

plot_final <- plot/ pr_curves+theme(legend.position = "none", 
                      axis.title = element_text(size= 15),
                      strip.text = element_text(size = 18))+
  plot_layout(heights = c(1,1.5))

ggexport(plot_final, filename = "results/specific_grns_mean_true_shuff_sd.pdf", width = 11, height = 10)

```
Final figure without permutations, clearer for the article :


```{r, fig.width=12, fig.height=10}

plot_MSE_gene_specific <- function(model_){
  lmses %>%
rownames_to_column("gene") %>%
reshape2::melt()%>%
  separate(variable,
           into = c("model", "dataset",  "rep"),
           sep = "_") %>%
filter(model == model_ & dataset == "trueData") %>%
group_by(dataset , rep) %>%
summarise(median_MSE = median(value, na.rm=T))%>%
  ggplot(aes(x=dataset, y = median_MSE)) + 
geom_boxplot(size = 1, alpha = 0.5, outlier.alpha = 0, 
             color = "#4670CD", fill = "#4670CD") +
theme_pubr() + geom_jitter(width = 0.2, size = 2,  color = "#4670CD")+
theme(
  strip.background = element_blank(),
  axis.line = element_blank(), 
  axis.title=element_blank(),
  axis.text=element_blank(),
  axis.ticks=element_blank(), 
  title = element_text(size = 16),
  strip.text = element_text(size = 16),
  legend.text = element_text(size = 15),
  legend.position = 'none'
)+ xlab("")+ ylab("MSE")
}
# gene specific MSE
mse_lasso_spec <- plot_MSE_gene_specific("LASSO")
mse_rf_spec <- plot_MSE_gene_specific("RF")

# MSE for global alphas
draw_mse <- function(model){
data <- lmses[as.numeric(str_split_fixed(colnames(lmses), '_', 4)[,4]) <=10] %>%
rownames_to_column("gene") %>%
reshape2::melt()%>%
  separate(variable,
           into = c("model", "alpha", "dataset",  "rep"),
           sep = "_") %>%
filter(model == model & dataset == "trueData") %>%
group_by(dataset, rep, alpha) %>%
summarise(median_MSE = median(value, na.rm=T))%>%
  group_by(alpha, dataset) %>%
  mutate(mean_median_mse = mean(median_MSE),
         sd_median_mse = sd(median_MSE)) %>%
  mutate(alpha = as.numeric(alpha))
data %>%
  ggplot(aes(x=alpha, y = median_MSE)) + 
  geom_line(aes(y=mean_median_mse, group = dataset), color = "#70AD47") +
  geom_ribbon(aes(ymin = mean_median_mse - sd_median_mse , 
                    ymax = mean_median_mse + sd_median_mse), 
                alpha = .4, color = "#70AD47", fill = "#70AD47")+ 
  xlab(expression(alpha)) +
theme_pubr() + geom_point(width = 0.2, size = 2, color = "#70AD47")+
theme(
  strip.background = element_blank(),
  axis.title.x = element_text(size = 22),
  title = element_text(size = 16),
  strip.text = element_text(size = 16),
  legend.text = element_text(size = 15),
  legend.position = 'top'
)+ ylab("MSE")
}

load("results/rdata/weightedLASSO_mse_50rep.rdata")
mse_lasso <- draw_mse("LASSO")

load("results/rdata/weightedRF_mse_100rep.rdata")
mse_rf <- draw_mse("RF")
x_min <- 0.19


plot <- (mse_lasso + ylim(c(x_min,0.26)) +labs(title = "weightedLASSO")+ 
           theme(plot.title = element_text(hjust = 1))+
  mse_lasso_spec+ ylim(c(x_min,0.26)) +ylab("") +
  mse_rf +  ylim(c(x_min,0.26)) +labs(title = "weightedRF")+
    theme(plot.title = element_text(hjust = 0.75))+ylab("") +
  mse_rf_spec+ ylim(c(x_min,0.26)) + ylab(""))+
  plot_layout(guides = "collect", ncol = 4, widths = c(3,1,3,1)) & 
  theme(legend.position = 'bottom', legend.text = element_text(size = 15))


pr_curves <- data_val %>%
  filter(dataset == "trueData") %>%
  ggplot(aes(x=recall, y=precision, 
             label = alpha, fill = alpha_type, color = alpha_type)) +
  geom_point(size = 0.65)+
  geom_ribbon(aes(ymin = mean_precision - sd_precision , 
                    ymax = mean_precision + sd_precision, x=mean_recall  ), alpha = 0.4)+
  theme_pubr()+ ggh4x::facet_nested_wrap(vars(model), nest_line = T)+
  geom_line(aes(y=mean_precision, x=mean_recall), size=2)+
  geom_label(aes(y=mean_precision, x=mean_recall), nudge_y = 0.02, fill = "white", show.legend = F)+
  theme(strip.background = element_blank(), 
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 18))+
  geom_hline(color = "#C55A11", linetype='dashed',
             yintercept = 0.331042, size= 1.5, show.legend = T) +
  geom_point(aes(x=recall, y=precision), data = val_spec[val_spec$dataset=="trueData",])+
  scale_color_manual(name = "Data integration",
                     values = setNames(c( "#4670CD", "#70AD47"), 
                                       c("gene-specific", "global")))+
  scale_fill_manual(name = "Data integration",
                     values = setNames(c( "#4670CD", "#70AD47"), 
                                       c("gene-specific", "global")))+
  xlab("Recall") + ylab("Precision")


plot_final <- plot/ pr_curves+theme(legend.position = "bottom", 
                      axis.title = element_text(size= 15),
                      strip.text = element_text(size = 18))+
  plot_layout(heights = c(1,1));plot_final


plot_final

ggexport(plot_final, filename = "results/specific_grns_no_permutations_mean_sds.pdf", 
         width = 11, height = 10)

```

In summary, gene-specific optimization of alpha allows to minimize the MSE, while still achieving near-optimal precision and a good recall in both models.


# Comparison of our approach with the simplest minimal MSE criterion

What is the difference between our approach (maximal divergence in MSE as compared to a synthetic baseline) and directly minimizing the MSE?

Intersection between genes benefiting from data integration with the minimal MSE criterion.

```{r}
load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO_min.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedRF_min.rdata")

venn <- ggVennDiagram(list("weightedRF" = names(alphas_rf[alphas_rf!=0]),
                   "weightedLASSO" = names(alphas_lasso[alphas_lasso!=0])), edge_size = 2)+ 
  scale_color_manual( values = c("#C55A11","#E67F87"))+
  scale_fill_gradient(high="#e6f2ff", low="#e6f2ff")+
  theme(legend.position = "none");venn

# hypergeometric test to assess the significance of the intersect
p_enrich <- phyper(q=582, m = length(names(alphas_rf[alphas_rf!=0])), 
                   n = length(genes) - length(names(alphas_rf[alphas_rf!=0])), 
                   k = length( names(alphas_lasso[alphas_lasso!=0])), lower.tail = F)
p_enrich
ggexport(venn, filename = "results/classes_intersection_min.pdf", width = 4, height = 4)
```

Differences between the two criteria for the same model : 

```{r}
alphas_lasso_min <- alphas_lasso
alphas_rf_min <- alphas_rf

load("results/rdata/gene_specific/alpha_per_gene_weightedLASSO.rdata")
load("results/rdata/gene_specific/alpha_per_gene_weightedRF.rdata")

alphas_lasso_div <- alphas_lasso
alphas_rf_div <- alphas_rf

saved_lasso <- setdiff(names(alphas_lasso_div[alphas_lasso_div > 0]), 
                             names(alphas_lasso_min[alphas_lasso_min > 0]))

saved_rf <- setdiff(names(alphas_rf_div[alphas_rf_div > 0]), 
                             names(alphas_rf_min[alphas_rf_min > 0]))

same_rf <- intersect(names(alphas_rf_div[alphas_rf_div > 0]), 
                             names(alphas_rf_min[alphas_rf_min > 0]))

lost_lasso <- setdiff(names(alphas_lasso_min[alphas_lasso_min > 0]),
                            names(alphas_lasso_div[alphas_lasso_div > 0]))

lost_rf <- setdiff(names(alphas_rf_min[alphas_rf_min > 0]),
                         names(alphas_rf_div[alphas_rf_div > 0]))

same_lasso <- intersect(names(alphas_lasso_min[alphas_lasso_min > 0]),
                        names(alphas_lasso_div[alphas_lasso_div > 0]))

matrix(c(length(same_lasso), length(lost_lasso), length(saved_lasso), 
         length(genes) - length(same_lasso) - length(lost_lasso) - length(saved_lasso)), 
       nrow = 2, byrow = F, dimnames = list(c("data integration div", "no data integration div"),
                                            c("data integration min", "no data integration min")))


```

For the RFs :

```{r}
matrix(c(length(same_rf), length(lost_rf), length(saved_rf), 
         length(genes) - length(same_rf) - length(lost_rf) - length(saved_rf)), 
       nrow = 2, byrow = F, dimnames = list(c("data integration div", "no data integration div"),
                                            c("data integration min", "no data integration min")))
```


## MSE, precision and recall analysis

We show only a small MSE increase of our approach, but precision and recall are both increased, even though TFBM integration is performed for less genes.


```{r, fig.width=10}
load("results/rdata/gene_specific/gene_specific_validation_min.rdata")
val_specific_min <- val_specific %>%
  mutate(criterion = "min MSE")
load("results/rdata/gene_specific/gene_specific_validation_mean_true_shuff_sd.rdata")
val_specific_dev <- val_specific%>%
  mutate(criterion = "proposed approach")

precision_recall_min_dev <- rbind.data.frame(val_specific_dev, val_specific_min) %>%
  filter(dataset == "trueData" & density < 0.05) %>%
  mutate(model = paste0("weighted", model),
         density = paste0("D = ", density)) %>%
  ggplot(aes(y = precision, x = recall, color = criterion, label = density)) + 
  geom_jitter()+
  facet_nested_wrap(vars(density, model), ncol = 2, scales = "free") + theme_bw()+
  theme(strip.background = element_blank()) +
  stat_ellipse() + ggtitle("Precision and recall")
```



```{r, fig.width = 10, fig.height=5}
load("results/rdata/gene_specific/gene_specific_mse_min.rdata")
mse_min <- lmses
colnames(mse_min) <- paste0(colnames(mse_min), '_min')
mse_min$genes <- rownames(mse_min)

load("results/rdata/gene_specific/gene_specific_mse_mean_true_shuff_sd.rdata")
mse_dev <- lmses
colnames(mse_dev) <- paste0(colnames(mse_dev), '_dev')
mse_dev$genes <- rownames(mse_dev)


mse_plot <- full_join(mse_dev, mse_min, by = c("genes"))  %>%
reshape2::melt()%>%
  separate(variable,
           into = c("model", "dataset",  "rep", "criterion"),
           sep = "_") %>%
filter(dataset == "trueData") %>%
group_by(rep, model, criterion) %>%
summarise(median_MSE = median(value, na.rm=T))%>%
  mutate(criterion = str_replace(criterion, "min", "min MSE"),
         criterion = str_replace(criterion, "dev", "proposed\napproach"),
         model = paste0("weighted", model)) %>%
  ggplot(aes(x=criterion, y = median_MSE, color = criterion, fill = criterion)) +
  geom_jitter(show.legend = F)+ ylab("Median MSE") + xlab("") +
  facet_nested_wrap(vars(model), nest_line = T) +
  theme_bw() + theme(strip.background = element_blank(), 
                     legend.position = "none") +
  ggtitle("Median MSE")

min_dev_plot <- mse_plot + precision_recall_min_dev + 
  plot_layout(guides = "collect", widths = c(1.5,2)) & 
  theme(legend.position = "bottom") 


ggexport(min_dev_plot, filename = "results/supp_figures/min_mse_comparison.pdf", width = 10, height = 5)
```
