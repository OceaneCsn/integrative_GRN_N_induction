---
title: "Integrative GRN inference : effect of permuting the expression and motifs of TFs on expression prediction"
output: 
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F, fig.width = 10)

source('inference_functions/weightedRF.R')
source('inference_functions/weightedLASSO.R')
source('inference_functions/evaluateNetwork.R')
source('inference_functions/MSE.R')
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(patchwork)
library(ComplexHeatmap)
```

This document demonstrates the use of the weightedRF and weightedLASSO functions for integrative GRN inference.

It shows how to select one optimal alpha value per gene, in order to apply data integration only to the target genes for which expression prediction error is reduced by using PWM prior information, significantly more than in a baseline model.

# Data import

Import of the expression data and the N-responsive genes and regulators :

```{r}
load('rdata/inference_input_N_response_varala.rdata')
genes <- input_data$grouped_genes; length(genes)
tfs <- input_data$grouped_regressors; length(tfs)
counts <- input_data$counts; dim(counts)
load("rdata/pwm_occurrences_N_response_varala.rdata")
dim(pwm_occurrence)


ALPHAS <- seq(0,1, by = 0.1)
```


# Prediction error as a function of data integration strengh (alpha) 

The following steps are time and CPU intensive, so the result files can just be loaded to be analysed in further steps.

## For weightedRF

Generating 100 repetitions of weightedRF MSE estimation on true data, and on shuffled data.

```{r}
lmses <- data.frame(row.names = genes)
N <-100
for(alpha in ALPHAS){
  for(perm in 1:N){
    lmses[,paste(as.character(alpha), perm, "true_data")] <- weightedRF_inference_MSE(counts, subset, tfs, alpha = alpha, nTrees = 2000,
                             pwm_occurrence = pwm_occurrence, nCores = 45, tf_expression_permutation = F)
  }

  for(perm in 1:N){
    lmses[,paste(as.character(alpha), perm, "shuffled")] <- weightedRF_inference_MSE(counts, subset, tfs, alpha = alpha, nTrees = 2000,
                           pwm_occurrence = pwm_occurrence, nCores = 45, tf_expression_permutation = T)
  }
}

save(lmses, file = "results/brf_perumtations_mse_all_genes_predict.rdata")
subset<-unique(rownames(lmses))
```


## For weightedLASSO 

Generating 100 repetitions of weightedLASSO MSE estimation on true data, and on shuffled data.

```{r, eval=FALSE}
lmses <- data.frame(row.names = subset)
N<-100
for(alpha in ALPHAS){
  for(perm in 1:N){
    lmses[,paste(as.character(alpha), perm, "true_data")] <- weightedLASSO_inference_MSE(counts, subset, tfs, alpha = alpha, N=100,
                             pwm_occurrence = pwm_occurrence, nCores = 40, tf_expression_permutation = F)

    lmses[,paste(as.character(alpha), perm, "shuffled")] <- weightedLASSO_inference_MSE(counts, subset, tfs, alpha = alpha, N=100,
                           pwm_occurrence = pwm_occurrence, nCores = 40, tf_expression_permutation = T)
  }
}
save(lmses, file = "results/lasso_perumtations_mse_all_genes.rdata")
```


# Getting the importance metrics of inferred edges in order to measure effective data integration and build inferred GRNs

## For weightedRF

```{r, eval=FALSE}
nCores = 45
mats <- list()
nrep <- 100
for(alpha in ALPHAS){ # exploring PWM integration strength
  for(rep in 1:nrep){ # exploring inherent variability
    
    mat_rf <- weightedRF_inference(counts, genes, tfs, nTrees = 2000,
                            alpha = alpha,
                            pwm_occurrence = pwm_occurrence,
                            nCores = nCores,
                            importance = "%IncMSE")
    
    mat_rf_perm <- weightedRF_inference(counts, genes, tfs, nTrees = 2000,
                            alpha = alpha, tf_expression_permutation = TRUE,
                            pwm_occurrence = pwm_occurrence,
                            nCores = nCores,
                            importance = "%IncMSE")
    
    mats[[paste0("bRF_", as.character(alpha),  '_trueData_', rep)]] <- mat_rf
    mats[[paste0("bRF_", as.character(alpha),  '_shuffled_', rep)]] <- mat_rf_perm
    
  }
}
save(mats, file = "results/100_permutations_bRF_importances_inf.rdata")

# thresholds the regulatory weights at a certain density to build GRNs
edges <- list()
densities <- c(0.005, 0.01,0.05)
for(name in names(mats)){ 
      for(density in densities){# exploring importance threshold stringency
        edges[[paste0(name, '_', density)]] <-
        weightedRF_network(mats[[name]], density = density, pwm_occurrence, genes, tfs)
      }
}
save(edges, file = "results/100_permutations_bRF_edges_inf.rdata")
```

## For weightedLASSO

```{r, eval=FALSE}
nCores = 45
mats <- list()
nrep <- 100
for(alpha in ALPHAS){ # exploring PWM integration strength
  for(rep in 1:nrep){ # exploring inherent variability
    
    mat_lasso <- weightedLASSO_inference(counts, genes, tfs,
                                     alpha = alpha, N = 100, robustness = 0.2,
                                     int_pwm_noise = 0, mda_type = "shuffle",
                                     pwm_occurrence = pwm_occurrence,
                                     nCores = nCores)
    
    mat_lasso_perm <- weightedLASSO_inference(counts, genes, tfs,
                                     alpha = alpha, N = 100, robustness = 0.2,
                                     tf_expression_permutation = TRUE,
                                     int_pwm_noise = 0, mda_type = "shuffle",
                                     pwm_occurrence = pwm_occurrence,
                                     nCores = nCores)
    
    mats[[paste0("LASSO_", as.character(alpha),  '_trueData_', rep)]] <- mat_lasso
    mats[[paste0("LASSO_", as.character(alpha),  '_shuffled_', rep)]] <- mat_lasso_perm
    
  }
}
save(mats, file = "results/100_permutations_lasso_importances_mda_shuffle.rdata")

# thresholds the regulatory weights at a certain density to build GRNs
edges <- list()
densities <- c(0.005, 0.01,0.05)
for(name in names(mats)){ 
      for(density in densities){# exploring importance threshold stringency
        edges[[paste0(name, '_', density)]] <-
        weightedLASSO_network(mats[[name]], density = density, pwm_occurrence, 
                          genes, tfs, decreasing = TRUE)
      }
}
save(edges, file = "results/100_permutations_lasso_edges_mda_shuffle.rdata")
```


# Showing the MSE and effective data integration behaviors


```{r}
# prior values
pwm_imputed <- pwm_occurrence
pwm_imputed[is.na(pwm_imputed)] <- 0.5

# parallel sapply to parallelise the computing of optimal alphas
mcsapply <- function (X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) {
  FUN <- match.fun(FUN)
  answer <- parallel::mclapply(X = X, FUN = FUN, ...)
  if (USE.NAMES && is.character(X) && is.null(names(answer))) 
    names(answer) <- X
  if (!isFALSE(simplify) && length(answer)) 
    simplify2array(answer, higher = (simplify == "array"))
  else answer
}
```

## weightedRF


```{r, fig.width=9, fig.height=8}
# importance metrics and MSE for weightedRF
load("results/brf_perumtations_mse_all_genes_predict.rdata")
load("results/100_permutations_bRF_importances_inf.rdata")


# needs an appropriate mats variable and a lmses variable to be loaded

# plots the importance of TFs that have a specific prior value, here one,
# as alpha is increased
draw_gene_effective_integration <- function(gene, prior=1, type = "rank"){
  tfs_with_motif <- names(which(pwm_imputed[gene,]== prior))
  if(type == "rank")
    data <- data.frame(lapply(mats, function(mat){mean(rank(mat[,gene])[tfs_with_motif])}))
  if(type == "imp")
    data <- data.frame(lapply(mats, function(mat){mean(mat[,gene][tfs_with_motif])}))
  plot <- data %>%
  gather(key = "setting", value = "summed_importance") %>%
  separate(setting, into = c("method", "alpha", "dataset", "rep"), sep = "_") %>%
  group_by(alpha, dataset) %>%
  mutate(mean_imp = mean(summed_importance),
            sd_imp = sd(summed_importance),
         alpha = as.numeric(alpha))%>%
  ggplot(aes(x=alpha, y = summed_importance, color = dataset, fill = dataset)) +
  geom_point(alpha = 0.1) + geom_line(aes(y=mean_imp))+
  geom_ribbon(aes(ymin = mean_imp - sd_imp , 
                    ymax = mean_imp + sd_imp  ), 
                alpha = .4)  +theme_pubr(legend = "none")+
    ylab("Rank of TFs with Pi=1")+
    ggtitle("Effective data integration") + 
    labs(subtitle = gene)+
    scale_color_manual(values = setNames(c("grey", "#70AD47"), c("shuffled", "trueData")))+
    scale_fill_manual(values = setNames(c("grey", "#70AD47"), c("shuffled", "trueData")))
  plot + xlab(expression(alpha))
}


# plots the MSE as alpha is increased
draw_gene_mse <- function(gene, title = NULL){
  lmses[gene, ] %>%
    gather() %>%
    separate(key,
             into = c("alpha", "rep", "MSEtype"),
             sep = " ") %>%
    group_by(alpha, MSEtype) %>%
    mutate(mean_mse = mean(value, na.rm = T),
           sd_mse = sd(value, na.rm = T),
           dataset = str_replace(MSEtype, "_data", "Data")) %>%
    ggplot(aes(
      x = as.numeric(alpha),
      y = value,
      color = dataset,
      fill = dataset
    )) +ggtitle(paste("MSE"))+ylab("MSE/Var(gene)")+
    geom_ribbon(aes(ymin = mean_mse - sd_mse , 
                    ymax = mean_mse + sd_mse  ), 
                alpha = .4)  +theme_pubr(legend = "top")+
    geom_point(alpha = 0.1) + geom_line(aes(y=mean_mse))+xlab(expression(alpha))+ 
    scale_color_manual(values = setNames(c("grey", "#70AD47"), c("shuffled", "trueData")))+
    scale_fill_manual(values = setNames(c("grey", "#70AD47"), c("shuffled", "trueData")))
}


# plots the MSE as a function of effective data integration
get_opt_alpha_per_gene <- function(gene, type = "rank", return_cluster = F){
  tfs_with_motif <- names(which(pwm_occurrence[gene,]==1))
  # gene with no TFBS has an optimal alpha of 0
  if(return_cluster & length(tfs_with_motif)==0) return(0)
  # else
  if(length(tfs_with_motif)>0){
    
  if(type == "rank")
    data <- data.frame(lapply(mats, function(mat){mean(rank(mat[,gene])[tfs_with_motif])}))
  if(type == "imp")
    data <- data.frame(lapply(mats, function(mat){mean(mat[,gene][tfs_with_motif])}))
  
  inte <- data %>%
  gather(key = "setting", value = "summed_importance") %>%
  separate(setting, into = c("method", "alpha", "dataset", "rep"), sep = "_") %>%
  group_by(alpha, dataset) %>%
  mutate(mean_imp = mean(summed_importance, na.rm=T),
            sd_imp = sd(summed_importance, na.rm=T),
         alpha = as.numeric(alpha))
  
  curves <- lmses[gene, ] %>%
    gather() %>%
    separate(key,
             into = c("alpha", "rep", "MSEtype"),
             sep = " ") %>%
    rename(dataset = MSEtype,)%>%
    mutate(alpha = as.numeric(alpha),
           dataset = str_replace(dataset, "true_data", "trueData"))%>%
    full_join(inte, by = c("alpha", "dataset", "rep")) %>%
    group_by(alpha, mean_imp, dataset) %>%
    summarise(mean_mse = mean(value, na.rm = T),
           sd_mse = sd(value, na.rm = T)) 
  curves <- curves %>%
  group_by(dataset) %>%
    arrange(dataset, mean_imp)%>%
      mutate(imps=curves[curves$dataset=="trueData", ]$mean_imp) %>%
      mutate(approx_mse = approx(mean_imp,mean_mse,curves[curves$dataset=="trueData", ]$mean_imp, rule=2)$y,
             approx_sd = approx(mean_imp,sd_mse,curves[curves$dataset=="trueData", ]$mean_imp, rule=2)$y) 
  
  
  true <- curves[curves$dataset=="trueData",]
  shuff <- curves[curves$dataset!="trueData",]
  
  true$div <- (shuff$approx_mse - shuff$approx_sd) - (true$mean_mse)
  if(max(true$div)>0) alpha_opt <- true[true$div == max(true$div),]$alpha
  else alpha_opt <- 0
  
  eff_opt = true[true$alpha==alpha_opt,]$mean_imp
  padding = ifelse(alpha_opt<0.2, 17, -17)
  if(return_cluster) return(alpha_opt)
  
  curves%>%
    ggplot(aes(y=mean_mse, x = mean_imp, color = dataset, fill = dataset))+
  # geom_ribbon(aes(ymin =mean_mse-sd_mse , 
  #                 ymax = mean_mse + sd_mse),  alpha = .4)+ 
    geom_ribbon(aes(x=imps,ymin =approx_mse-approx_sd ,
                  ymax = approx_mse + approx_sd), alpha = .25)+
    geom_point(alpha = 0.1, size = 0.5) +
    geom_line(aes(x=mean_imp, y = mean_mse), size=1) + 
      # geom_line(aes(x=imps, y = approx_mse), col="black")+
  theme_pubr(legend = "none") +
    ylab("MSE/Var(gene)") + xlab("Effective data integration") + ggtitle("MSE=f(effective integration)")+ 
    scale_color_manual(values = setNames(c("grey", "#70AD47"), c("shuffled", "trueData")))+
    scale_fill_manual(values = setNames(c("grey", "#70AD47"), c("shuffled", "trueData")))+
    geom_vline(xintercept = eff_opt, size = 2, col="#4670CD") +
  annotate("text", x=eff_opt+padding, y=max(shuff$mean_mse), 
           label=paste("Optimal\nintegration:\nalpha =", alpha_opt), 
           angle=0, col = "#4670CD", size =3.5 )
  }
  else ggplot()
}


gene_no_benefit <- "AT1G30270"
gene_benefit_optimum <- "AT1G14720"
gene_benefit <- "AT1G30080"

n <- draw_gene_effective_integration(gene_no_benefit, prior = 1) +
  draw_gene_mse(gene_no_benefit)+
  get_opt_alpha_per_gene(gene_no_benefit)+
  plot_annotation(title = gene_no_benefit) 
o <- draw_gene_effective_integration(gene_benefit_optimum, prior = 1) +
  draw_gene_mse(gene_benefit_optimum)+theme(legend.position = "none")+
  get_opt_alpha_per_gene(gene_benefit_optimum)+
  plot_annotation(title = gene_benefit_optimum) 
p <- draw_gene_effective_integration(gene_benefit, prior = 1) +
  draw_gene_mse(gene_benefit)+theme(legend.position = "none")+
  get_opt_alpha_per_gene(gene_benefit)+
  plot_annotation(title = gene_benefit)


figure <- n/o/p
ggexport(figure, filename = "results/gene_examples_weightedRF.pdf", width = 10, height = 9)


# value of alpha per genes:
alphas_rf <- mcsapply(genes, get_opt_alpha_per_gene, type = "rank", 
                          return_cluster=T, mc.cores=34)
save(alphas_rf, file = "results/alpha_per_gene_weighted_RF.rdata")


load("results/alpha_per_gene_weighted_RF.rdata")


```


Doing the same for weightedLASSO:


```{r}

# for the lasso
load("results/lasso_perumtations_mse_all_genes.rdata")
load("results/100_permutations_lasso_importances_mda_shuffle.rdata")


gene_no_benefit <- "AT1G30270"
gene_benefit_optimum <- "AT1G14720"
gene_benefit <- "AT1G30080"

n <- draw_gene_effective_integration(gene_no_benefit, prior = 1) +
  draw_gene_mse(gene_no_benefit)+
  get_opt_alpha_per_gene(gene_no_benefit)+
  plot_annotation(title = gene_no_benefit) 
o <- draw_gene_effective_integration(gene_benefit_optimum, prior = 1) +
  draw_gene_mse(gene_benefit_optimum)+theme(legend.position = "none")+
  get_opt_alpha_per_gene(gene_benefit_optimum)+
  plot_annotation(title = gene_benefit_optimum) 
p <- draw_gene_effective_integration(gene_benefit, prior = 1) +
  draw_gene_mse(gene_benefit)+theme(legend.position = "none")+
  get_opt_alpha_per_gene(gene_benefit)+
  plot_annotation(title = gene_benefit)


figure <- n/o/p
ggexport(figure, filename = "results/gene_examples_weightedLASSO.pdf", width = 10, height = 9)


# value of alpha per genes:
alphas_lasso <- mcsapply(genes, get_opt_alpha_per_gene, type = "rank", 
                          return_cluster=T, mc.cores=34)
save(alphas_lasso, file = "results/alpha_per_gene_weighted_LASSO.rdata")

```

# Plotting MSE behaviour for all genes

Depending on their class (optimal alpha different from 0 or not).

## weightedRF

```{r}
load("results/brf_perumtations_mse_all_genes_predict.rdata")
load(file = "results/alpha_per_gene_weighted_RF.rdata")

pos_class <- names(alphas_rf[alphas_rf!=0])

mse <- lmses[str_detect(colnames(lmses), "true_data")]
for(alpha in seq(0,1, by = 0.1)){
  mse[,paste("alpha",alpha)] <- rowMeans(mse[,str_detect(colnames(mse), paste0("^",as.character(alpha), " "))])
}
mse <- as.matrix(mse[str_detect(colnames(mse), "alpha")])
mse_interest <- mse[pos_class,]
mse_other <- mse[setdiff(rownames(mse), pos_class),]

library(circlize)
col_fun = colorRamp2(c(-2, 0, 2), hcl_palette = "Blue-Red 3")

ha = HeatmapAnnotation(
    alpha = anno_simple(as.numeric(str_remove(colnames(mse), "alpha "))),
    annotation_name_side = "left")

pdf("results/rf_mse_interest.pdf", height = 5)
Heatmap((mse_interest-rowMeans(mse_interest))/matrixStats::rowSds(mse_interest), 
        col = col_fun, show_column_names = F,
         width = ncol(mse_interest)*unit(10, "mm"), 
      height = nrow(mse_interest)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F, top_annotation = ha)+ 
  rowAnnotation(class = ifelse(alphas_rf[rownames(mse_interest)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
pdf("results/rf_mse_others.pdf", height = 10)
Heatmap((mse_other-rowMeans(mse_other))/matrixStats::rowSds(mse_other),
        col = col_fun,show_column_names = F,
        width = ncol(mse_other)*unit(10, "mm"), 
      height = nrow(mse_other)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F, top_annotation = ha)+ 
  rowAnnotation(class = ifelse(alphas_rf[rownames(mse_other)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
```

# Intersection between classes


```{r}
library(ggVennDiagram)
ggVennDiagram("weightedLASSO" = )
```



```{r, fig.height=7}

load("results/lasso_perumtations_mse_all_genes.rdata")
load(file = "results/alpha_per_gene_weighted_LASSO.rdata")

pos_class <- names(alphas_lasso[alphas_lasso!=0])

mse <- lmses[str_detect(colnames(lmses), "true_data")]
for(alpha in seq(0,1, by = 0.1)){
  mse[,paste("alpha",alpha)] <- rowMeans(mse[,str_detect(colnames(mse), paste0("^",as.character(alpha), " "))])
}
mse <- as.matrix(mse[str_detect(colnames(mse), "alpha")])
mse_interest <- mse[pos_class,]
mse_other <- mse[setdiff(rownames(mse), pos_class),]

library(circlize)
col_fun = colorRamp2(c(-2, 0, 2), hcl_palette = "Blue-Red 3")

ha = HeatmapAnnotation(
    alpha = anno_simple(as.numeric(str_remove(colnames(mse), "alpha "))),
    annotation_name_side = "left")

pdf("results/lasso_mse_interest.pdf", height = 5)
Heatmap((mse_interest-rowMeans(mse_interest))/matrixStats::rowSds(mse_interest), 
        col = col_fun, show_column_names = F,
         width = ncol(mse_interest)*unit(10, "mm"), 
      height = nrow(mse_interest)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F, top_annotation = ha)+ 
  rowAnnotation(class = ifelse(alphas_lasso[rownames(mse_interest)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()
pdf("results/lasso_mse_others.pdf", height = 10)
Heatmap((mse_other-rowMeans(mse_other))/matrixStats::rowSds(mse_other),
        col = col_fun,show_column_names = F,
        width = ncol(mse_other)*unit(10, "mm"), 
      height = nrow(mse_other)*unit(0.2, "mm"),
        cluster_columns = F, show_row_names = F, top_annotation = ha)+ 
  rowAnnotation(class = ifelse(alphas_lasso[rownames(mse_other)]>0, 
                               "class of interest", "no integration"), 
                col = list(class = setNames(c("#70AD47", "grey"), 
                                            nm = c("class of interest", "no integration"))))
dev.off()

```

# Intersection between classes


```{r}
library(ggVennDiagram)
venn <- ggVennDiagram(list("weightedRF" = names(alphas_rf[alphas_rf!=0]),
                   "weightedLASSO" = names(alphas_lasso[alphas_lasso!=0])), color="black")+ 
  scale_fill_gradient(low = "#EEEEEE", high = "#4670CD")+scale_color_manual(values = c("grey", "grey"))+
  theme(legend.position = "none")

# hypergeometric test to assess the significance of the intersect
p_enrich <- phyper(q=148, m = length(names(alphas_rf[alphas_rf!=0])), 
                   n = length(genes) - length(names(alphas_rf[alphas_rf!=0])), 
                   k = length( names(alphas_lasso[alphas_lasso!=0])), lower.tail = F)
p_enrich

ggexport(venn, filename = "results/classes_intersection.pdf", width = 4, height = 4)
```


# Clustering genes for RFs

Based on the difference curves between true and permuted data


```{r}
load("results/brf_perumtations_mse_all_genes_predict.rdata")
load("results/alphas_per_genes.rdata")
diffs <- get_diff_curves(lmses)

fractions_out <- diffs %>%
  mutate(diff_greater_than_sd = ifelse(abs(mean_mse_diff)>1, 1, 0)) %>%
  group_by(gene) %>%
  summarise(fraction_out = sum(diff_greater_than_sd)/11);fractions_out<-
  setNames(fractions_out$fraction_out, fractions_out$gene)

diff_curves <- diffs[c("gene", "alpha", "mean_mse_diff")] %>%
  spread(alpha, mean_mse_diff) %>%
  column_to_rownames("gene") %>%
  as.matrix()


diff_curves<-diff_curves[fractions_out[rownames(diff_curves)] > 0,]
  
cor_clust = function(x) hclust(as.dist(1-cor(t(x))), method = "average")


clusters_rf <- cutree(cor_clust(diff_curves), k = 2)
table(clusters_rf)

clusters_rf<- c(clusters_rf,setNames(rep("no diff", sum(fractions_out==0)),
                                     names(fractions_out[fractions_out==0])))
table(clusters_rf)
save(clusters_rf, file = "results/clusters_mse_bRF_100permutations.rdata")

for(gene in sample(genes,40, replace = F)){
    print(draw_gene(gene)+
            draw_gene_mean_sd(gene, title = paste(clusters_rf[gene], round(fractions_out[gene], 4))))
}


for(gene in c("AT1G08090", "AT1G12110")){
    print(draw_gene(gene)+
            draw_gene_mean_sd(gene, title = paste(clusters_rf[gene], round(fractions_out[gene], 4))))
}



ha = HeatmapAnnotation(
    alpha = anno_simple(as.numeric(rep(colnames(diff_curves),1))),
    annotation_name_side = "left")
# draw a heatmap of the genes mean_mse on real data
true_mse <- diffs[c("gene", "alpha", "mean_mse")] %>%
  spread(alpha, mean_mse) %>%
  column_to_rownames("gene") %>%
  as.matrix() 
  

true_mse_pos <- true_mse[names(clusters_rf[clusters_rf==2]),]
Heatmap((true_mse-rowMeans(true_mse))/matrixStats::rowSds(true_mse),
        cluster_columns = F, show_row_names = F, top_annotation = ha)+ 
  rowAnnotation(
    clusters_rf = clusters_rf[rownames(true_mse)],
    col=list(clusters_rf= setNames(c("darkorange", "darkgreen", "lightgrey"), 
                                       nm = names(table(clusters_rf)))))

Heatmap((true_mse_pos-rowMeans(true_mse_pos))/matrixStats::rowSds(true_mse_pos),
        cluster_columns = F, show_row_names = F, top_annotation = ha)+ 
  rowAnnotation(
    clusters_rf = clusters_rf[rownames(true_mse_pos)],
    col=list(clusters_rf= setNames(c("darkorange", "darkgreen", "lightgrey"), 
                                       nm = names(table(clusters_rf)))))
```



# Clustering genes for LASSO

Based on the difference curves between true and permuted data


```{r}
load("results/lasso_perumtations_mse_all_genes.rdata")
diffs <- get_diff_curves(lmses)
diffs %>%
  ggplot(aes(x=as.numeric(alpha), y=mean_mse_diff, group = gene))+
  geom_line(alpha = 0.2)


fractions_out <- diffs %>%
  mutate(diff_greater_than_sd = ifelse(abs(mean_mse_diff)>1, 1, 0)) %>%
  group_by(gene) %>%
  summarise(fraction_out = sum(diff_greater_than_sd)/11);fractions_out<-
  setNames(fractions_out$fraction_out, fractions_out$gene)

diff_curves <- diffs[c("gene", "alpha", "mean_mse_diff")] %>%
  spread(alpha, mean_mse_diff) %>%
  column_to_rownames("gene") %>%
  as.matrix()


diff_curves<-diff_curves[fractions_out[rownames(diff_curves)] > 0,]
  
cor_clust = function(x) hclust(as.dist(1-cor(t(x))), method = "average")

Heatmap(diff_curves, cluster_rows = cor_clust,
        cluster_columns = F, show_row_names = F)


clusters_lasso <- cutree(cor_clust(diff_curves), k = 2)
table(clusters_lasso)

clusters_lasso<- c(clusters_lasso,setNames(rep("no diff", sum(fractions_out==0)),
                                     names(fractions_out[fractions_out==0])))
table(clusters_lasso)
save(clusters_lasso, file = "results/clusters_mse_lasso_100permutations.rdata")

for(gene in sample(genes,20, replace = F)){
    print(draw_gene(gene)+
            draw_gene_mean_sd(gene, title = paste(clusters_lasso[gene], round(fractions_out[gene], 4))))
}

ha = HeatmapAnnotation(
    alpha = anno_simple(as.numeric(rep(colnames(diff_curves),1))),
    annotation_name_side = "left")
# draw a heatmap of the genes mean_mse on real data
true_mse <- diffs[c("gene", "alpha", "mean_mse")] %>%
  spread(alpha, mean_mse) %>%
  column_to_rownames("gene") %>%
  as.matrix() 
  

true_mse_pos <- true_mse[names(clusters_lasso[clusters_lasso==1]),]
Heatmap((true_mse-rowMeans(true_mse))/matrixStats::rowSds(true_mse),
        cluster_columns = F, show_row_names = F, top_annotation = ha)+ 
  rowAnnotation(
    clusters_lasso = clusters_lasso[rownames(true_mse)],
    col=list(clusters_lasso= setNames(c( "darkgreen","darkorange", "lightgrey"), 
                                       nm = names(table(clusters_lasso)))))

Heatmap((true_mse_pos-rowMeans(true_mse_pos))/matrixStats::rowSds(true_mse_pos),
        cluster_columns = F, show_row_names = F, top_annotation = ha)+ 
  rowAnnotation(
    clusters_lasso = clusters_lasso[rownames(true_mse_pos)],
    col=list(clusters_lasso= setNames(c("darkgreen","darkorange", "lightgrey"), 
                                       nm = names(table(clusters_lasso)))))
```

# Functional study of those groups

```{r}
load("rdata/pwm_prom_jaspar_dap.rdata")
load("rdata/gene_structure.rdata")

mean_expr <- rowMeans(counts)[genes]
var_expr <- matrixStats::rowSds(counts[genes,])*matrixStats::rowSds(counts[genes,])
pwm_prom_n_TFs <- pwm_prom[pwm_prom$TF %in% tfs,]

library(patchwork)

# to comment for new version where mse is already normalized per genes
# norm_mse <- exp(as.matrix(cbind(lmses, lmses_lasso)))/var_expr
genes_info <- data.frame(genes = genes, 
                         cluster_rf = clusters_rf[genes],
                         cluster_lasso = clusters_lasso[genes])

genes_info$is_tf <- genes %in% tfs
genes_info$var <- var_expr
genes_info$expr <- mean_expr
genes_info$min_mse <- matrixStats::rowMins(as.matrix(true_mse))
genes_info$nb_motifs <- table(pwm_prom$target)[genes]
genes_info$nb_motifs_n_tfs <- table(pwm_prom_n_TFs$target)[genes]

genes_info[,c("n_introns", "n_transcripts")] <- 
  gene_structure[match(genes_info$gene, gene_structure$gene),
                 c("n_introns", "n_transcripts")]

genes_info%>%
  ggplot(aes(x=cluster_rf, y=log(n_introns))) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Number of introns for RF groups")) +
genes_info%>%
  ggplot(aes(x=cluster_rf, y=n_transcripts)) + 
  geom_boxplot(width=0.1, fill = "white")+
  geom_violin(fill="darkblue", alpha=0.2)+
  ggtitle(("Number of transcripts for RF groups")) + 
  stat_compare_means()

genes_info%>%
  ggplot(aes(x=cluster_rf, y=nb_motifs)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Number of motifs in promoter for RF groups")) + 
  genes_info%>%
  ggplot(aes(x=cluster_rf, y=nb_motifs_n_tfs)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Number of motifs of N-responsive TFs in promoter for RF groups")) + 
  stat_compare_means() + genes_info%>%
  ggplot(aes(x=cluster_rf, y=min_mse)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Min mse for RF groups")) + 
  stat_compare_means() 


genes_info%>%
  ggplot(aes(x=cluster_rf, y=var)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Gene variance for RF groups")) + scale_y_log10()+
  stat_compare_means()+ genes_info%>%
  ggplot(aes(x=cluster_rf, y=expr)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Gene expression for RF groups")) + scale_y_log10()+
  stat_compare_means()


genes_info %>%
  group_by(cluster_rf) %>%
  summarise(n=n(), 
            tf_frac=sum(is_tf)/n()) %>%
  ggplot(aes(x=cluster_rf, y=tf_frac, 
                          label = paste("n=",n))) + 
  geom_bar(stat = "identity", aes(fill=tf_frac), alpha = 1)+
  geom_hline(yintercept = length(tfs)/length(genes)) + 
  geom_text(y=0.2) + xlab("cluster RF") +
  ggtitle("Fraction of TFs in RF groups")+ylim(c(0,0.2))







genes_info%>%
  ggplot(aes(x=cluster_lasso, y=log(n_introns))) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Number of introns for LASSO groups")) +
genes_info%>%
  ggplot(aes(x=cluster_lasso, y=n_transcripts)) + 
  geom_boxplot(width=0.1, fill = "white")+
  geom_violin(fill="darkblue", alpha=0.2)+
  ggtitle(("Number of transcripts for LASSO groups")) + 
  stat_compare_means()

genes_info%>%
  ggplot(aes(x=cluster_lasso, y=nb_motifs)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Number of motifs in promoter for LASSO groups")) + 
  genes_info%>%
  ggplot(aes(x=cluster_lasso, y=nb_motifs_n_tfs)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Number of motifs of N-responsive TFs in promoter for LASSO groups")) + 
  stat_compare_means() + genes_info%>%
  ggplot(aes(x=cluster_lasso, y=min_mse)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Min mse for LASSO groups")) + 
  stat_compare_means() 


genes_info%>%
  ggplot(aes(x=cluster_lasso, y=var)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Gene variance for LASSO groups")) + scale_y_log10()+
  stat_compare_means()+ genes_info%>%
  ggplot(aes(x=cluster_lasso, y=expr)) + 
  geom_violin(fill="darkblue", alpha=0.2)+geom_jitter(width=0.1)+
  geom_boxplot(width=0.1, fill = "white")+
  ggtitle(("Gene expression for LASSO groups")) + scale_y_log10()+
  stat_compare_means()


genes_info %>%
  group_by(cluster_lasso) %>%
  summarise(n=n(), 
            tf_frac=sum(is_tf)/n()) %>%
  ggplot(aes(x=cluster_lasso, y=tf_frac, 
                          label = paste("n=",n))) + 
  geom_bar(stat = "identity", aes(fill=tf_frac), alpha = 1)+
  geom_hline(yintercept = length(tfs)/length(genes)) + 
  geom_text(y=0.2) + xlab("cluster RF") +
  ggtitle("Fraction of TFs in RF groups")+ylim(c(0,0.2))

```




```{r}
# promoteurs enrichis en certains motifs de TFs?
known_tfs <- tfs[which(tfs %in% pwm_prom$TF)]

get_number_of_motifs_per_tfs <- function(genes){
  table(pwm_prom[pwm_prom$target %in% genes & pwm_prom$TF %in% tfs,"TF"])[known_tfs]
}

targets_per_pwm <- data.frame(row.names = known_tfs)
for(group in unique(clusters_rf)){
  targets_per_pwm[paste("lasso", group)] <- get_number_of_motifs_per_tfs(names(
    which(clusters_lasso == group)))/sum(clusters_lasso == group)
  targets_per_pwm[paste("rf", group)] <- get_number_of_motifs_per_tfs(names(
    which(clusters_rf == group)))/sum(clusters_rf == group)

}

enrichments_per_pwm <- data.frame(row.names = known_tfs)
n_genes <- length(genes)
for(group in unique(clusters_rf)){
  # number of motifs in all the genes
  n_targets_lasso_in_all <- get_number_of_motifs_per_tfs(genes)
  
  n_targets_lasso_in_group <- get_number_of_motifs_per_tfs(names(
    which(clusters_lasso == group)))
  n_group_lasso <- length(names(which(clusters_lasso == group)))
  
  n_targets_rf_in_group <- get_number_of_motifs_per_tfs(names(
    which(clusters_rf == group)))
  n_group_rf <- length(names(which(clusters_rf == group)))
  
  for(tf in known_tfs){
    
    # number of genes with that motif in all genes
    n_targets_in_all_tf <- n_targets_lasso_in_all[tf]
    
    # number of genes with that motif in the lasso group
    n_targets_lasso_in_group_tf <- n_targets_lasso_in_group[tf]
    p_lasso <- phyper(q=n_targets_lasso_in_group_tf-1,
           m=n_targets_in_all_tf, #white balls
           n=n_genes-n_targets_in_all_tf, # black balls
           k=n_group_lasso, lower.tail = FALSE)
    
     # number of genes with that motif in the rf group
    n_targets_rf_in_group_tf <- n_targets_rf_in_group[tf]
    p_rf <- phyper(q=n_targets_rf_in_group_tf-1,
           m=n_targets_in_all_tf, 
           n=n_genes-n_targets_in_all_tf,
           k=n_group_rf, lower.tail = FALSE)
    
    enrichments_per_pwm[tf, paste0(group, "lasso")]<- p_lasso
    enrichments_per_pwm[tf, paste0(group, "rf")]<- p_rf
  }
}

enrichments_per_pwm[enrichments_per_pwm<0.05] <- 0
enrichments_per_pwm[enrichments_per_pwm>=0.05] <- 1
Heatmap(enrichments_per_pwm, cluster_columns = F)


tfs_rf_pwm_pos <- rownames(enrichments_per_pwm[enrichments_per_pwm$`2rf`==0,])
tfs_lasso_pwm_pos <- rownames(enrichments_per_pwm[enrichments_per_pwm$`1lasso`==0,])
DIANE::get_gene_information(tfs_rf_pwm_pos, organism = "Arabidopsis thaliana")
DIANE::get_gene_information(tfs_lasso_pwm_pos, organism = "Arabidopsis thaliana")
DIANE::get_gene_information(intersect(tfs_rf_pwm_pos, tfs_lasso_pwm_pos ), organism = "Arabidopsis thaliana")

tfs_rf_pwm_bad <- rownames(enrichments_per_pwm[enrichments_per_pwm$`1rf`==0,])
tfs_lasso_pwm_bad <- rownames(enrichments_per_pwm[enrichments_per_pwm$`2lasso`==0,])
DIANE::get_gene_information(tfs_rf_pwm_bad, organism = "Arabidopsis thaliana")
DIANE::get_gene_information(tfs_lasso_pwm_bad, organism = "Arabidopsis thaliana")

tfs_rf_pwm_pretty_bad <- rownames(enrichments_per_pwm[enrichments_per_pwm$`no diffrf`==0,])
tfs_lasso_pwm_pretty_bad <- rownames(enrichments_per_pwm[enrichments_per_pwm$`no difflasso`==0,])
DIANE::get_gene_information(tfs_rf_pwm_pretty_bad, organism = "Arabidopsis thaliana")
DIANE::get_gene_information(tfs_lasso_pwm_pretty_bad, organism = "Arabidopsis thaliana")
```


# Network ranks of the Tfs that have enriched motifs in some gene clusters



```{r, fig.width=10, fig.height=10, eval=FALSE}
load("results/100_permutations_bRF_edges.rdata")
# 10 first replicates
edges <- edges[names(edges)[as.numeric(str_split_fixed(names(edges), '_', 5)[,4])<=10]]
net <- edges$bRF_1_trueData_1_0.005
# nodes <- 
get_nodes_relative_rank <- function(net, nodes){
  return(setNames(rank(table(net$from))[nodes]/length(unique(net$from)),nodes))
}

positive_genes <- names(clusters_rf[clusters_rf==2])
edges_positives <- lapply(edges, function(net){net[net$to %in% positive_genes,]})

negative_genes <- names(clusters_rf[clusters_rf==1])
edges_negatives <- lapply(edges, function(net){net[net$to %in% negative_genes,]})


relative_rank <- lapply(edges, get_nodes_relative_rank, tfs_rf_pwm_pos)
relative_rank_pos <- lapply(edges_positives, get_nodes_relative_rank, tfs_rf_pwm_pos)

data.frame(relative_rank) %>%
  rownames_to_column("gene") %>%
  reshape2::melt() %>%
  separate(variable, into = c("method", "alpha", "dataset", "rep", "density"), sep = '_', remove = F) %>%
  mutate(alpha = as.numeric(alpha)) %>%
  ggplot(aes(x=alpha, y=value, color = dataset)) + 
  ggh4x::facet_nested_wrap(vars(density, gene), nest_line = T) + 
  geom_point() + geom_smooth() +
  theme(strip.background = element_blank(), axis.title.x = element_text(size = 22),
        title = element_text(size = 16), strip.text = element_text(size = 16), 
        legend.text = element_text(size = 15), axis.text = element_text(size = 12), 
        legend.position = 'left') + ggtitle("TFs with motifs enriched in positive genes promoters : relative out-degree rank")


data.frame(relative_rank_pos) %>%
  rownames_to_column("gene") %>%
  reshape2::melt() %>%
  separate(variable, into = c("method", "alpha", "dataset", "rep", "density"), sep = '_', remove = F) %>%
  mutate(alpha = as.numeric(alpha)) %>%
  ggplot(aes(x=alpha, y=value, color = dataset)) + 
  ggh4x::facet_nested_wrap(vars(density, gene), nest_line = T) + 
  geom_point() + geom_smooth() +
  theme(strip.background = element_blank(), axis.title.x = element_text(size = 22),
        title = element_text(size = 16), strip.text = element_text(size = 16), 
        legend.text = element_text(size = 15), axis.text = element_text(size = 12), 
        legend.position = 'left') + ggtitle("TFs with motifs enriched in positive genes promoters : relative out-degree rank in positive subset")



relative_rank_bad <- lapply(edges, get_nodes_relative_rank, tfs_rf_pwm_bad)
relative_rank_bad_subset <- lapply(edges_negatives, get_nodes_relative_rank, tfs_rf_pwm_bad)

data.frame(relative_rank_bad) %>%
  rownames_to_column("gene") %>%
  reshape2::melt() %>%
  separate(variable, into = c("method", "alpha", "dataset", "rep", "density"), sep = '_', remove = F) %>%
  mutate(alpha = as.numeric(alpha)) %>%
  ggplot(aes(x=alpha, y=value, color = dataset)) + 
  ggh4x::facet_nested_wrap(vars(density, gene), nest_line = T) + 
  geom_point() + geom_smooth() +
  theme(strip.background = element_blank(), axis.title.x = element_text(size = 22),
        title = element_text(size = 16), strip.text = element_text(size = 16), 
        legend.text = element_text(size = 15), axis.text = element_text(size = 12), 
        legend.position = 'left') + ggtitle("TFs with motifs enriched in negative genes promoters : relative out-degree rank")

data.frame(relative_rank_bad_subset) %>%
  rownames_to_column("gene") %>%
  reshape2::melt() %>%
  separate(variable, into = c("method", "alpha", "dataset", "rep", "density"), sep = '_', remove = F) %>%
  mutate(alpha = as.numeric(alpha)) %>%
  ggplot(aes(x=alpha, y=value, color = dataset)) + 
  ggh4x::facet_nested_wrap(vars(density, gene), nest_line = T) + 
  geom_point() + geom_smooth() +
  theme(strip.background = element_blank(), axis.title.x = element_text(size = 22),
        title = element_text(size = 16), strip.text = element_text(size = 16), 
        legend.text = element_text(size = 15), axis.text = element_text(size = 12), 
        legend.position = 'left') + ggtitle("TFs with motifs enriched in negative genes promoters : relative out-degree rank in negative subset")

```



# Go enrichments

```{r, eval=T}
library(DIANE)
background <- convert_from_agi(genes)

for(group in unique(clusters_rf)){
  
  genes_i <- names(which(clusters_lasso == group))

  print(paste("LASSO", length(genes_i), "genes,", group, "\n"))
  genes_i <- convert_from_agi(genes_i)
  go_lasso <- enrich_go(genes_i, background)
  DIANE::draw_enrich_go(go_lasso)
  print(go_lasso)
  genes_i <- names(which(clusters_rf == group))
  print(paste("RF", length(genes_i), "genes, group", group))
  genes_i <- convert_from_agi(genes_i)
  go_rf <- enrich_go(genes_i, background)
  DIANE::draw_enrich_go(go_rf)
  print(go_rf)
}



```

# Expression


```{r}
expression <- data.frame(counts)
expression <- (expression-rowMeans(expression)) / matrixStats::rowSds(as.matrix(expression))

Heatmap(expression, cluster_columns = F, show_row_names = F)+
  rowAnnotation(
    clusters_rf = clusters_rf[rownames(expression)],
    clusters_lasso = clusters_lasso[rownames(true_mse)],
    col=list(clusters_lasso= setNames(c( "darkgreen","darkorange", "lightgrey"), 
                                       nm = names(table(clusters_lasso))),
      clusters_rf= setNames(c("darkorange", "darkgreen", "lightgrey"), 
                                       nm = names(table(clusters_rf)))))

```


# intersection of groups

```{r}
load("results/clusters_mse_bRF_100permutations.rdata")
load("results/clusters_mse_lasso_100permutations.rdata")
DIANE::draw_venn(list("positive for lasso" = names(clusters_lasso[clusters_lasso==1]),
                      "positive for RFs" = names(clusters_rf[clusters_rf==2])))

DIANE::draw_venn(list("negative for lasso" = names(clusters_lasso[clusters_lasso==2]),
                      "negative for RFs" = names(clusters_rf[clusters_rf==1])))

DIANE::draw_venn(list("no diff for lasso" = names(clusters_lasso[clusters_lasso=="no diff"]),
                      "no diff for RFs" = names(clusters_rf[clusters_rf=="no diff"])))
```






